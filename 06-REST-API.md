# REST API

## REST API Basics

**#. What is REST and what does it stand for?**

REST stands for Representational State Transfer. It's an architectural style for designing networked applications, introduced by Roy Fielding in 2000. REST treats server objects as resources that can be created, read, updated, or deleted. Each resource is identified by a URI. REST uses standard HTTP methods (GET, POST, PUT, DELETE) and is stateless - each request contains all information needed to process it. RESTful services are lightweight, scalable, and platform-independent. They typically use JSON or XML for data exchange. REST is not a protocol or standard, it's a set of constraints and principles. Most modern web APIs follow REST principles because they're simple, scalable, and leverage existing HTTP infrastructure.

**#. What are the main principles/constraints of REST?**

REST has six constraints: **1) Client-Server** - separation of concerns, clients and servers evolve independently. **2) Stateless** - each request is independent, server doesn't store client context between requests. **3) Cacheable** - responses must define themselves as cacheable or not to improve performance. **4) Uniform Interface** - standardized way of interacting with resources using HTTP methods and URIs. **5) Layered System** - client can't tell if connected directly to server or intermediary (load balancer, proxy). **6) Code on Demand (optional)** - servers can extend client functionality by sending executable code. Following these constraints makes APIs scalable, reliable, and maintainable. Most REST APIs follow the first five constraints.

**#. Explain the difference between REST and SOAP.**

REST is an architectural style using HTTP naturally. SOAP (Simple Object Access Protocol) is a protocol with strict standards. **REST**: uses HTTP methods (GET, POST, etc.), typically JSON (can be XML), lightweight, stateless, flexible, easier to implement, better performance. **SOAP**: uses only POST, always XML, heavyweight, can be stateful, rigid standards (WSDL, WS-Security), more complex, supports built-in error handling and security. REST is resource-oriented, SOAP is action-oriented. Example: REST uses GET /users/123, SOAP sends XML with action getUserById. Use REST for public APIs, mobile apps, microservices - it's simpler. Use SOAP for enterprise applications requiring ACID transactions, formal contracts, or built-in security standards. REST has largely replaced SOAP for modern APIs.

**#. What are HTTP methods and their purposes in REST?**

HTTP methods define operations on resources. **GET** - retrieve resource, safe and idempotent, no side effects, example: GET /users/123 gets user 123. **POST** - create new resource, not idempotent, example: POST /users creates user. **PUT** - update entire resource (replace), idempotent, example: PUT /users/123 replaces user 123. **PATCH** - partial update, example: PATCH /users/123 updates specific fields. **DELETE** - delete resource, idempotent, example: DELETE /users/123 deletes user 123. **HEAD** - like GET but only headers, no body. **OPTIONS** - describes communication options for resource. Proper method usage is crucial for RESTful design. Use GET for retrieval, POST for creation, PUT/PATCH for updates, DELETE for deletion.

**#. What is the difference between PUT and PATCH?**

Both update resources but differ in scope. **PUT** replaces the entire resource - you send complete representation. If you omit fields, they're cleared or set to defaults. Idempotent - same request multiple times has same effect. Example: PUT /users/123 {name: "John", email: "john@example.com", age: 30} replaces all user data. **PATCH** partially updates - you send only fields to change. Other fields remain unchanged. May or may not be idempotent depending on implementation. Example: PATCH /users/123 {email: "newemail@example.com"} updates only email. Use PUT when you have complete data and want to replace. Use PATCH for partial updates - more efficient and avoids accidentally clearing fields. PATCH is more common in practice for updates.

**#. Explain idempotency in REST APIs.**

Idempotent means multiple identical requests have the same effect as a single request. **Idempotent methods**: GET (reading doesn't change anything), PUT (replacing resource multiple times results in same state), DELETE (deleting already-deleted resource has no additional effect). **Non-idempotent**: POST (creating same user twice creates two users - different effect). PATCH can be idempotent or not depending on implementation. Idempotency is important for reliability - if a request times out, you can safely retry idempotent requests without unintended side effects. Example: DELETE /users/123 is safe to retry - user is deleted once, subsequent attempts just return 404. POST /orders is not safe to retry - might create duplicate orders. Design APIs to be idempotent where possible for robustness.

**#. What are safe methods in HTTP?**

Safe methods don't modify server state - they're read-only operations. Only GET, HEAD, and OPTIONS are safe. They have no side effects and can be cached aggressively. You can call them repeatedly without changing data. POST, PUT, PATCH, DELETE are unsafe - they modify data. Safe doesn't mean secure (that's HTTPS). It means no state changes. Importance: browsers and proxies can cache safe methods, automatically retry them, prefetch them. Search engine crawlers only follow safe methods. Users can bookmark safe URIs. Design GET endpoints to be truly safe - don't use GET for actions like "GET /users/123/delete". Use appropriate unsafe methods for modifications. Understanding safe vs unsafe helps with caching, retry logic, and proper REST design.

**#. What is a REST resource and how do you identify it?**

A resource is any information that can be named - user, order, product, document, etc. It's the key abstraction in REST. Resources are identified by URIs (Uniform Resource Identifiers). Each resource has a unique URI. Examples: /users (collection of users), /users/123 (specific user), /users/123/orders (user's orders). Resources can be in different formats (representations) - JSON, XML, HTML. The URI identifies the resource, not the format. Use nouns for resources, not verbs: /users not /getUsers. Use plural nouns: /products not /product. Hierarchical structure shows relationships: /users/123/orders. Good resource design makes APIs intuitive and RESTful.

**#. Explain the difference between URI, URL, and URN.**

**URI (Uniform Resource Identifier)** is the general term - an identifier for a resource. Two types: URL and URN. **URL (Uniform Resource Locator)** specifies location and access method. Example: https://api.example.com/users/123 - tells you where and how to access the resource. **URN (Uniform Resource Name)** is a name in a namespace, location-independent. Example: urn:isbn:0-486-27557-4 identifies a book by ISBN without specifying location. All URLs are URIs, all URNs are URIs, but not all URIs are URLs or URNs. In practice, REST APIs use URLs. The term URI is used in specifications, but URL is what we mean. The distinction matters theoretically but less practically.

**#. What are HTTP status codes and their categories?**

Status codes indicate request outcome. Five categories: **1xx Informational** - request received, processing continues (rarely used). **2xx Success** - request successfully received, understood, accepted. **3xx Redirection** - further action needed to complete request. **4xx Client Error** - request has an error, client's fault. **5xx Server Error** - server failed to fulfill valid request, server's fault. Common codes: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error, 503 Service Unavailable. Choose appropriate codes - don't return 200 for errors or 500 for bad requests. Status codes communicate what happened without parsing response body.

**#. Explain common 2xx success status codes.**

**200 OK** - standard success response, has body with requested data. Use for successful GET, PUT, PATCH. **201 Created** - resource successfully created. Use for successful POST. Should include Location header with new resource URI. Body typically contains created resource. **202 Accepted** - request accepted for processing but not completed. Use for async operations. **204 No Content** - success but no content to return. Use for successful DELETE or updates that don't return data. Empty response body. **206 Partial Content** - partial resource returned, used with range requests. Choose 200 for most successes, 201 specifically for creation, 204 when no body needed. Proper success codes improve API clarity.

**#. Explain common 4xx client error status codes.**

**400 Bad Request** - malformed request, validation error, unparseable JSON. Generic client error. **401 Unauthorized** - authentication required or failed. Should include WWW-Authenticate header. **403 Forbidden** - authenticated but not authorized for this resource. **404 Not Found** - resource doesn't exist. **405 Method Not Allowed** - HTTP method not supported for resource. Include Allow header. **409 Conflict** - conflict with current resource state, like duplicate creation. **422 Unprocessable Entity** - request well-formed but semantically invalid, validation errors. **429 Too Many Requests** - rate limit exceeded. Include Retry-After header. Use specific codes when applicable - helps clients handle errors appropriately. 400 is catch-all, but specific codes are better.

**#. Explain common 5xx server error status codes.**

**500 Internal Server Error** - generic server error, something went wrong. Shouldn't expose details to clients. **501 Not Implemented** - server doesn't support functionality required. **502 Bad Gateway** - server acting as gateway got invalid response from upstream. **503 Service Unavailable** - server temporarily unavailable, overloaded or maintenance. Include Retry-After header. **504 Gateway Timeout** - gateway didn't receive timely response from upstream. 5xx means server's fault, client did nothing wrong. Log these for monitoring. Don't return 5xx for client errors like validation failures. Use 500 sparingly - only for unexpected errors. More specific codes help with debugging. Clients typically retry 5xx errors after delay.

**#. What is content negotiation in REST?**

Content negotiation allows client to specify desired response format. Server returns data in requested format if supported. **Two approaches**: **1) Accept header** - client sends Accept: application/json or Accept: application/xml. Server responds with matching Content-Type. **2) URL parameter** - /users/123?format=json or file extension like /users/123.json. Accept header is more RESTful. Server can also negotiate on: character encoding (Accept-Charset), language (Accept-Language), compression (Accept-Encoding). If server can't satisfy request, returns 406 Not Acceptable. Benefits: same API serves multiple formats, clients get optimal format. JSON is default for most modern APIs, but XML, CSV, or custom formats may be needed for different clients.

**#. Explain REST API versioning strategies.**

Common strategies: **1) URI versioning** - /v1/users, /v2/users. Simple, clear, but clutters URIs. Most common. **2) Query parameter** - /users?version=1. Less visible, easy to add. **3) Header versioning** - custom header Accept-Version: v1 or media type Accept: application/vnd.company.v1+json. RESTful, keeps URI clean, but less visible. **4) Content negotiation** - different media types for versions. **5) No versioning** - evolve API compatibly. Each has tradeoffs. URI versioning is most popular for visibility and simplicity. Choose one strategy consistently. Version when making breaking changes. Maintain old versions for transition period. Document deprecation timelines. Version major changes, evolve minor changes compatibly.

**#. What is HATEOAS?**

HATEOAS (Hypermedia As The Engine Of Application State) is a REST constraint where responses include links to related actions/resources. Client interacts with application through hypermedia links, not hardcoded URIs. Example response: {id: 123, name: "John", _links: {self: "/users/123", orders: "/users/123/orders", delete: {href: "/users/123", method: "DELETE"}}}. Benefits: discoverability (client learns available actions from responses), loose coupling (server can change URIs without breaking clients), self-documenting API. Few APIs fully implement HATEOAS - it's complex and often unnecessary. Partial HATEOAS is common - including some links. Fully RESTful APIs include HATEOAS, but pragmatic APIs often skip it. It's the highest level of REST maturity.

**#. What is the Richardson Maturity Model?**

Richardson Maturity Model describes four REST maturity levels: **Level 0 (POX - Plain Old XML)** - single URI, single method (usually POST), RPC style. Like SOAP. **Level 1 (Resources)** - multiple URIs for different resources, but still single method. **Level 2 (HTTP Verbs)** - proper use of HTTP methods (GET, POST, PUT, DELETE) and status codes. Most REST APIs are here. **Level 3 (Hypermedia Controls)** - HATEOAS, responses include links. Rare. Climbing levels increases RESTfulness. Level 2 is practical target for most APIs. Level 3 is ideal but complex. Understanding this model helps evaluate and design APIs. Most modern APIs are Level 2, which balances pragmatism with REST principles.

**#. What are the advantages of REST APIs?**

Key advantages: **Scalability** - stateless nature allows easy horizontal scaling. **Flexibility** - client-server separation, multiple formats supported. **Platform independence** - works over HTTP, any platform with HTTP client can consume. **Simplicity** - easy to understand and implement, leverages familiar HTTP. **Cacheable** - responses can be cached for performance. **Visibility** - stateless requests are easier to monitor and debug. **Reliability** - idempotent methods allow safe retries. **Loose coupling** - client and server evolve independently. **Wide adoption** - standard approach, many tools and libraries. **Performance** - efficient, especially with caching. These make REST ideal for web services, microservices, mobile apps, and public APIs.

**#. What are REST API best practices?**

Best practices: Use nouns for resources, verbs for actions through HTTP methods. Plural nouns: /users not /user. Hierarchical URIs for relationships: /users/123/orders. Proper status codes - 2xx success, 4xx client error, 5xx server error. Version APIs: /v1/users. Use query params for filtering/sorting/pagination: /users?status=active&page=2. Accept and return JSON (XML if needed). Use HTTPS always. Implement authentication (JWT, OAuth). Use standard date/time format (ISO 8601). Include correlation IDs for tracing. Document thoroughly (OpenAPI/Swagger). Handle errors consistently with clear messages. Implement rate limiting. Support CORS for browser clients. Keep APIs consistent across endpoints. Validate input. Log requests for monitoring.

**#. How do you design RESTful URLs?**

URL design guidelines: Use nouns, not verbs: /products not /getProducts. Use plural nouns: /users not /user. Use hierarchy for relationships: /users/123/orders not /getUserOrders?userId=123. Keep URLs short and intuitive. Use hyphens for readability: /user-profiles not /user_profiles or /userProfiles. Lowercase letters only. Don't include file extensions: /users/123 not /users/123.json (use Accept header). Use query parameters for filtering, sorting, pagination: /products?category=electronics&sort=price&page=2. Avoid deeply nested URLs (max 2-3 levels). Bad: /users/getActiveUsersInDepartment. Good: /users?status=active&department=IT. Collection: /users. Individual: /users/123. Action on individual: POST /users/123/activate. Good URLs are self-documenting and intuitive.

## REST API Authentication & Security

**#. What are common authentication methods for REST APIs?**

Common methods: **1) Basic Authentication** - username:password encoded in Base64 in Authorization header. Simple but insecure unless over HTTPS. **2) API Keys** - client sends key in header or query param. Simple, good for server-to-server. **3) JWT (JSON Web Tokens)** - self-contained tokens with claims, signed. Stateless, scalable. **4) OAuth 2.0** - industry standard for delegated authorization, access tokens. Complex but secure. **5) OAuth 1.0a** - older, more complex, less common. **6) Session-based** - session ID in cookie, not truly RESTful (stateful). **7) HMAC** - requests signed with shared secret. Choose based on use case: JWT for SPAs/mobile, OAuth for third-party access, API keys for server-to-server. Always use HTTPS. Tokens should expire and be refreshable.

**#. Explain Basic Authentication.**

Basic Authentication sends credentials in Authorization header: Authorization: Basic base64(username:password). Example: Authorization: Basic am9objpzZWNyZXQ=. Server decodes and validates credentials. **Pros**: simple, built into HTTP, widely supported. **Cons**: credentials sent with every request, must use HTTPS (base64 is encoding not encryption), no logout mechanism, harder to revoke access. Use only over HTTPS. Suitable for simple use cases or development. Not recommended for production web applications - use OAuth or JWT instead. Good for internal tools or server-to-server where simplicity matters and environment is controlled. Always use strong passwords. Consider rate limiting to prevent brute force attacks.

**#. What are API Keys and how do they work?**

API Keys are unique identifiers for authentication. Generated by server, provided to client. Client includes in requests via: custom header (X-API-Key: abc123), query parameter (?api_key=abc123), or Authorization header. Server validates key against database. **Pros**: simple, good for identifying applications, easy to revoke, separate keys for different apps/environments. **Cons**: no user identity (application-level only), if compromised, attacker has full access until revoked, no expiration unless implemented. Use cases: server-to-server communication, public APIs with usage tracking, mobile apps (though JWT better). Best practices: use HTTPS, store keys securely (not in code repository), rotate regularly, different keys for prod/dev, rate limit per key, log usage for monitoring.

**#. What is JWT and how does it work?**

JWT (JSON Web Token) is a compact, self-contained way to transmit information between parties as JSON. Structure: header.payload.signature. **Header** - algorithm and type: {alg: "HS256", typ: "JWT"}. **Payload** - claims (data): {userId: 123, exp: 1234567890}. **Signature** - validates token hasn't been tampered: HMACSHA256(base64(header) + "." + base64(payload), secret). Example JWT: eyJhbGc.eyJ1c2Vy.SflKx. Flow: user logs in, server creates JWT with user info and signs it, returns to client, client includes in Authorization: Bearer <token>, server validates signature and extracts claims. **Pros**: stateless, scalable, self-contained (no database lookup). **Cons**: can't revoke (until expiry), size (larger than session ID). Use exp claim for expiration. Don't store sensitive data (tokens are readable).

**#. Explain OAuth 2.0.**

OAuth 2.0 is an authorization framework allowing third-party applications limited access to resources without sharing credentials. Key concepts: **Resource Owner** (user), **Client** (application), **Resource Server** (API), **Authorization Server** (issues tokens). **Flow**: user authorizes client, authorization server issues access token, client uses token to access resource server. Four grant types: **Authorization Code** (most secure, for web apps), **Implicit** (for SPAs, deprecated), **Client Credentials** (server-to-server), **Password** (user provides credentials to client, avoid if possible). Tokens: **access token** (short-lived, access resources), **refresh token** (long-lived, get new access token). OAuth is for authorization, not authentication (use OpenID Connect for that). Use for third-party integrations, social login, microservices.

**#. What is the difference between authentication and authorization?**

**Authentication** verifies who you are - proves identity. "Are you really John?" Credentials: username/password, JWT, biometrics. Results in identity token/session. **Authorization** determines what you can do - checks permissions. "Can John access this resource?" Based on roles, permissions, ACLs. Happens after authentication. Example: logging in is authentication, checking if you can delete a file is authorization. In HTTP: 401 Unauthorized (actually means unauthenticated), 403 Forbidden (authenticated but not authorized). Flow: first authenticate (prove identity), then authorize (check permissions). Authentication happens once per session, authorization happens per request/action. REST APIs need both - JWT for authentication, role/permission checks for authorization.

**#. How do you secure REST APIs?**

Security best practices: **1) Use HTTPS always** - encrypt in transit. **2) Authentication** - JWT, OAuth 2.0, API keys. **3) Authorization** - role-based access control (RBAC), check permissions per endpoint. **4) Input validation** - sanitize and validate all input, prevent injection attacks. **5) Rate limiting** - prevent abuse and DDoS. **6) CORS configuration** - restrict origins that can access API. **7) API keys/secrets management** - store securely, rotate regularly. **8) Logging and monitoring** - track access, detect anomalies. **9) Error handling** - don't expose sensitive info in errors. **10) Encryption** - sensitive data at rest. **11) Security headers** - X-Content-Type-Options, X-Frame-Options, etc. **12) Versioning** - maintain security fixes in old versions. **13) Dependencies** - keep libraries updated. **14) Penetration testing** - regular security audits.

**#. What is CORS and why is it important?**

CORS (Cross-Origin Resource Sharing) is a browser security mechanism controlling which domains can access your API from JavaScript. Same-Origin Policy blocks cross-origin requests by default. CORS uses headers to allow them. **Key headers**: Access-Control-Allow-Origin (allowed origins), Access-Control-Allow-Methods (allowed HTTP methods), Access-Control-Allow-Headers (allowed request headers), Access-Control-Allow-Credentials (allow cookies). **Preflight**: for certain requests (PUT, DELETE, custom headers), browser sends OPTIONS request first. Server responds with allowed methods/headers. Then actual request proceeds. **Configuration**: wildcard (*) allows all origins (only for public APIs), specific origins for security, credentials require specific origin (not *). Important for SPAs calling APIs on different domains. Configure appropriately - too permissive is security risk, too restrictive breaks legitimate clients.

**#. What is rate limiting and why is it needed?**

Rate limiting restricts number of requests a client can make in a time period. Purposes: **prevent abuse** - stop malicious users from overwhelming API. **ensure fair usage** - prevent one user from consuming all resources. **control costs** - especially for paid APIs or third-party service calls. **protect infrastructure** - prevent DDoS, maintain availability. **implement tiers** - free tier gets 100 req/hour, paid gets 10000. **Common algorithms**: token bucket (tokens regenerate over time), leaky bucket (requests processed at fixed rate), fixed window (count resets at intervals), sliding window (rolling time window). Return 429 Too Many Requests when limit exceeded. Include headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset. Rate limit by: IP, API key, user ID. Essential for production APIs.

**#. How do you implement token-based authentication?**

Flow: **1) Login** - POST /auth/login with credentials. **2) Server validates** - check credentials against database. **3) Generate token** - create JWT with user claims, sign with secret. **4) Return token** - {accessToken: "...", refreshToken: "..."}. **5) Client stores** - localStorage, sessionStorage, or memory (XSS risk with storage). **6) Subsequent requests** - include in Authorization: Bearer <token> header. **7) Server validates** - verify signature, check expiration, extract user info. **8) Refresh** - when access token expires, POST /auth/refresh with refresh token, get new access token. **Implementation**: use library (jsonwebtoken in Node, jjwt in Java). Access token: short-lived (15 min), refresh token: long-lived (7 days). Store refresh token securely (httpOnly cookie or database). Invalidate on logout. Include claims: userId, roles, exp.

**#. What is the Bearer token authentication scheme?**

Bearer token authentication is a HTTP authentication scheme where client sends token in Authorization header: Authorization: Bearer <token>. "Bearer" indicates token type - the bearer (possessor) of the token is authorized. The token itself (usually JWT) contains authentication information. Server validates token without needing to look up session. **Usage**: Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.... **Why "Bearer"?** - differentiates from other schemes (Basic, Digest). Anyone with the token (bearer) can use it, so protect it like a password. **Pros**: stateless, scalable, works across domains. **Cons**: if stolen, attacker has access (use HTTPS, short expiration). Standard for OAuth 2.0 access tokens and JWT. Most modern REST APIs use Bearer token authentication.

**#. How do you handle token expiration and refresh?**

Use two tokens: **access token** (short-lived, 15-30 min) and **refresh token** (long-lived, 7-30 days). **Flow**: 1) User logs in, gets both tokens. 2) Access API with access token. 3) When access token expires (401 response), client calls /auth/refresh with refresh token. 4) Server validates refresh token, issues new access token (and optionally new refresh token). 5) Client retries original request with new token. **Security**: refresh tokens stored securely (httpOnly cookie or database), can be revoked, rotate on each refresh (detect token theft). **Client handling**: automatically refresh before expiration or on 401. **Backend**: maintain refresh token whitelist/blacklist, invalidate on logout/suspicious activity. This balance security (short access token) with UX (don't re-login frequently).

**#. What are security headers for REST APIs?**

Important security headers: **Strict-Transport-Security** - enforce HTTPS: Strict-Transport-Security: max-age=31536000. **X-Content-Type-Options** - prevent MIME sniffing: X-Content-Type-Options: nosniff. **X-Frame-Options** - prevent clickjacking: X-Frame-Options: DENY. **Content-Security-Policy** - control resource loading: Content-Security-Policy: default-src 'self'. **X-XSS-Protection** - enable XSS filter: X-XSS-Protection: 1; mode=block. **Referrer-Policy** - control referrer info: Referrer-Policy: no-referrer. **Permissions-Policy** - control browser features: Permissions-Policy: geolocation=(). Set these at server/reverse proxy level. They add defense-in-depth. Not all apply to APIs (some browser-specific), but HSTS and Content-Type-Options are important. Many frameworks/middleware can set these automatically.

**#. How do you implement API key management?**

Best practices: **Generation** - use cryptographically secure random strings, sufficient length (32+ chars). **Storage** - hash like passwords (SHA-256), store hash not plaintext. **Distribution** - secure channel, never in code repositories, use environment variables. **Rotation** - allow key rotation without downtime, support multiple active keys during transition, set expiration dates. **Scope** - different keys for different environments (dev/staging/prod), limit permissions per key (read-only, write, etc.). **Monitoring** - log key usage, alert on suspicious activity, track quotas per key. **Revocation** - easy revocation process, immediate effect. **Documentation** - clearly document key usage for users. Store securely: environment variables, secret management services (AWS Secrets Manager, HashiCorp Vault). Never commit to git. Audit key usage regularly.

**#. What is HMAC and when do you use it?**

HMAC (Hash-based Message Authentication Code) verifies message integrity and authenticity using cryptographic hash function and secret key. For APIs, client signs requests with shared secret. **Process**: 1) Client creates signature - HMAC(secret, request_data). 2) Includes signature in header: X-Signature: <signature>. 3) Server recomputes signature with same secret and request data. 4) Compares signatures - if match, request is authentic and unmodified. **Request data typically**: HTTP method, URL, timestamp, body hash. **Use cases**: webhooks (verify sender), server-to-server APIs (mutual authentication), when OAuth is overkill but need strong authentication. **Pros**: verifies sender and message integrity, prevents replay attacks (with timestamp), no token to steal. **Cons**: requires shared secret (key distribution), more complex than bearer tokens. Examples: AWS Signature, Webhook signatures.

## REST API Request & Response

**#. What are query parameters and when do you use them?**

Query parameters are key-value pairs appended to URL after ?. Format: /users?status=active&role=admin. **Use cases**: **Filtering** - /products?category=electronics&brand=Sony. **Sorting** - /users?sort=created_at&order=desc. **Pagination** - /items?page=2&limit=20. **Search** - /products?q=laptop. **Optional parameters** - anything that doesn't identify the resource. **Don't use for**: resource identification (use path /users/123 not /users?id=123), sensitive data (logged in URLs), large data (use POST body). URL encode values: /search?q=coffee%20maker. Multiple values: ?tags=java&tags=spring or ?tags=java,spring. Query params are great for optional, non-identifying information. Keep URLs under 2000 chars (browser limits). Document clearly what parameters are supported.

**#. What is the difference between path parameters and query parameters?**

**Path parameters** are part of URL path identifying resource: /users/{userId}/orders/{orderId}. Example: /users/123/orders/456. Required, hierarchical, identify resource. **Query parameters** come after ?: /users?status=active&page=2. Optional (usually), flat key-value, filter/modify results. **Path param use**: resource identification, hierarchical relationships, required parameters, RESTful design. Example: /api/v1/users/123. **Query param use**: filtering, sorting, pagination, searching, optional parameters. Example: /api/v1/users?role=admin&page=1. Rule of thumb: if it identifies a resource uniquely, use path param. If it filters or modifies, use query param. Bad: /getUser?id=123. Good: /users/123. Path params are part of resource URI, query params modify how you view that resource.

**#. How do you handle pagination in REST APIs?**

Common pagination approaches: **1) Offset/Limit** - /users?offset=20&limit=10 or /users?page=3&size=10. Simple, but slow for large offsets. **2) Cursor-based** - /users?cursor=abc123&limit=10. Cursor is opaque token pointing to position. Efficient, consistent for real-time data. **3) Page number** - /users?page=3. Easy to understand. **Response should include**: data array, total count, page info (current page, total pages, has_next). Example: {data: [...], page: 3, size: 10, total: 543, totalPages: 55}. **Headers**: Link header with next/prev/first/last URLs: Link: </users?page=4>; rel="next". HATEOAS: include _links in response. **Best practices**: default limits (20-50), max limits (500-1000), document clearly, consistent across endpoints. Offset/limit is most common. Cursor-based for feeds/infinite scroll.

**#. How do you implement filtering and sorting in REST APIs?**

**Filtering**: use query params. Simple: ?status=active. Multiple: ?status=active&role=admin. Operators: ?age_gte=18&age_lte=65 (greater than/less than). In: ?status=active,pending. Search: ?q=john. Range: ?created_at_from=2024-01-01&created_at_to=2024-12-31. Alternative syntax: ?filter[status]=active. **Sorting**: ?sort=created_at or ?orderBy=created_at. Direction: ?sort=created_at&order=desc or ?sort=-created_at (minus for descending). Multiple: ?sort=last_name,first_name. **Implementation**: parse query params, build database query dynamically. Validate: whitelist allowed fields, validate operators. **Limits**: don't allow sorting/filtering on all fields (performance, security). Document supported fields. Example: GET /products?category=electronics&price_gte=100&sort=-price&page=1.

**#. What are the best practices for API request/response design?**

Request best practices: use appropriate HTTP method, validate input, use JSON for body, meaningful URIs, include required headers (Content-Type, Authorization). Response best practices: **Consistent structure** - same format across endpoints: {data: {}, error: null} or {success: true, data: {}}. **Proper status codes** - 2xx for success, 4xx for client errors, 5xx for server errors. **Error details** - {error: {code: "VALIDATION_ERROR", message: "...", details: [...]}}. **Timestamps** - ISO 8601 format: "2024-03-15T10:30:00Z". **Enveloping** - wrap data: {data: {user: {}}} vs bare {user: {}} - enveloping is cleaner for metadata. **Include metadata** - pagination info, timestamps, request ID. **Null vs omission** - consistent handling. **Camel case** - {firstName: "John"} for JSON. Keep responses focused - don't include unnecessary data. Document thoroughly.

**#. How do you handle partial responses (field selection)?**

Allow clients to request only needed fields to reduce bandwidth and improve performance. **Approaches**: **1) fields parameter** - /users/123?fields=id,name,email returns only those fields. Comma-separated list. **2) Sparse fieldsets** (JSON:API) - /users/123?fields[users]=name,email. **3) GraphQL** - but that's different paradigm. **Implementation**: parse fields parameter, select only requested columns from database, serialize only requested fields. **Related resources**: /users/123?fields=id,name&include=orders returns user with orders embedded. **Wildcards**: fields=* for all, fields=user.* for nested. **Benefits**: reduced payload size, faster responses, lower bandwidth cost, mobile-friendly. **Challenges**: complexity, caching difficulty (more cache variations). Most APIs don't implement this - nice-to-have, not critical. JSON:API standard includes this. Document clearly if supported.

**#. What are HTTP headers and which ones are important for REST APIs?**

Headers provide metadata about request/response. **Request headers**: **Content-Type** - format of request body (application/json). **Accept** - desired response format. **Authorization** - credentials (Bearer token). **User-Agent** - client info. **X-Request-ID** - correlation ID for tracing. **If-Match/If-None-Match** - conditional requests with ETags. **Response headers**: **Content-Type** - response format. **Location** - new resource URI (with 201). **Cache-Control** - caching directives. **ETag** - resource version for caching. **X-RateLimit-** * - rate limit info. **X-Request-ID** - same as request for correlation. **Retry-After** - when to retry (with 429, 503). **Link** - pagination links. **Access-Control-** * - CORS headers. Custom headers should start with X- (though deprecated, still common). Headers are crucial for API metadata, caching, authentication, CORS.

**#. What is the Content-Type header and common values?**

Content-Type specifies media type of request/response body. Tells receiver how to parse content. Format: Content-Type: type/subtype. **Common values**: **application/json** - most common for REST APIs. **application/xml** - XML data. **application/x-www-form-urlencoded** - form data (key=value&key2=value2). **multipart/form-data** - file uploads with form data. **text/plain** - plain text. **text/html** - HTML. **text/csv** - CSV data. **application/pdf** - PDF files. **image/jpeg, image/png** - images. Use in requests when sending body (POST, PUT, PATCH): Content-Type: application/json. Server should validate Content-Type. Return in responses: Content-Type: application/json; charset=utf-8. Charset specifies encoding (UTF-8 is standard). Mismatch between Content-Type and actual content causes parsing errors.

**#. What is the Accept header?**

Accept header specifies what media types client can handle in response. Client negotiates format. Format: Accept: type/subtype. **Examples**: **Accept: application/json** - wants JSON. **Accept: application/xml** - wants XML. **Accept: */** - accepts anything. **Accept: application/json, application/xml;q=0.9** - prefers JSON, will accept XML. q is quality factor (0-1), higher is preferred. Server responds with one of acceptable types and sets Content-Type header. If server can't provide any acceptable type, returns 406 Not Acceptable. Most REST APIs only support JSON, so Accept is often ignored or defaults to JSON. Useful when supporting multiple formats (JSON, XML, CSV). Content negotiation with Accept is part of REST principles but underutilized in practice. JSON is ubiquitous now.

**#. How do you handle file uploads in REST APIs?**

Use multipart/form-data encoding with POST/PUT. **Simple upload**: POST /files with Content-Type: multipart/form-data. File in form field. **With metadata**: POST /users/123/avatar with file and metadata (name, description) in form fields. **Multiple files**: multiple file fields in form. **Large files**: chunked uploads - split file, upload chunks, reassemble server-side. Or signed upload URLs (S3 presigned URLs) - client uploads directly to storage. **Response**: 201 Created with Location header: Location: /files/abc123. Body: {id: "abc123", url: "https://...", size: 1024000}. **Implementation**: use middleware (multer in Express, MultipartFile in Spring). Validate: file type, size limit. Store: local filesystem, S3, cloud storage. Security: scan for malware, restrict file types, use signed URLs for downloads. Consider dedicated upload service for scaling.

**#. How do you handle bulk operations in REST APIs?**

Approaches for operations on multiple resources: **1) Batch endpoint** - POST /users/batch with array: {users: [{name: "..."}, {name: "..."}]}. Returns array of results with individual statuses. **2) Separate requests** - client makes multiple requests. Simple but inefficient. **3) Bulk query parameters** - DELETE /users?ids=1,2,3. Less RESTful. **4) Async processing** - POST /users/bulk-import returns job ID, client polls GET /jobs/123 for status. For large batches. **Best practices**: limit batch size (100-1000 items), partial success handling (some succeed, some fail), return detailed results per item: [{id: 1, status: "success"}, {id: 2, status: "error", error: "..."}]. Use 207 Multi-Status for partial success. Transactional batches: all-or-nothing with rollback. Consider job queue for async processing.

**#. What is the purpose of OPTIONS HTTP method?**

OPTIONS describes communication options for target resource. Two uses: **1) CORS preflight** - browser sends OPTIONS before actual request to check if cross-origin request is allowed. Server responds with Access-Control-* headers indicating allowed methods, headers, origins. **2) Discovery** - client checks what methods are supported: OPTIONS /users. Server responds with Allow: GET, POST, PUT, DELETE. Also can return documentation or metadata. Example response: Allow: GET, POST, HEAD, OPTIONS. Access-Control-Allow-Methods: GET, POST, PUT, DELETE. Most APIs implement OPTIONS for CORS. For discovery, often not implemented (documentation used instead). OPTIONS requests shouldn't have side effects. Usually handled automatically by framework/web server for CORS. Important for browser-based API clients.

**#. How do you implement conditional requests with ETags?**

ETag (Entity Tag) is a version identifier for a resource. Enables efficient caching and concurrency control. **Flow**: 1) Client requests resource: GET /users/123. 2) Server responds with ETag: ETag: "abc123xyz". 3) Client caches response with ETag. 4) Client requests again with If-None-Match: "abc123xyz". 5) If unchanged, server returns 304 Not Modified (no body). If changed, returns 200 with new data and ETag. **For updates** (prevent lost updates): 1) Client GETs resource, receives ETag. 2) Client modifies and PUTs with If-Match: "abc123xyz". 3) If ETag matches, update succeeds (200). If mismatch (someone else updated), returns 412 Precondition Failed. **Implementation**: generate ETag from content hash or version number. ETags improve caching and prevent concurrent update conflicts.

**#. How do you handle cache control in REST APIs?**

Use Cache-Control header to control caching behavior. **Directives**: **no-cache** - cache but revalidate before using (conditional request with ETag). **no-store** - don't cache at all (sensitive data). **private** - cache only in browser, not in intermediate caches. **public** - cache anywhere (CDN, proxy, browser). **max-age=3600** - cache for 3600 seconds. **must-revalidate** - revalidate stale cache. **Combinations**: Cache-Control: public, max-age=86400 (cache publicly for 1 day). Cache-Control: private, no-cache (validate every time). Cache-Control: no-store (never cache). **Use cases**: static resources (long max-age), frequently changing data (short max-age or no-cache), sensitive data (no-store). Also use Expires header (older) and Last-Modified for conditional requests. Proper caching dramatically improves performance and reduces server load.

**#. What are some common REST API anti-patterns?**

Anti-patterns to avoid: **1) RPC-style URLs** - /getUser, /updateUser instead of GET /users, PUT /users. **2) Verbs in URLs** - /users/create instead of POST /users. **3) Using GET for modifications** - GET /users/123/delete. **4) Ignoring HTTP methods** - using only GET and POST. **5) Wrong status codes** - returning 200 for errors. **6) Inconsistent naming** - /users vs /user, /getUsers vs /fetchUser. **7) Not versioning** - breaking changes without version. **8) Exposing implementation** - /users.php, /api/database/users. **9) Not using proper authentication** - session-based (stateful). **10) Ignoring HTTP features** - no caching, no ETags, no status codes. **11) Chatty APIs** - requiring many requests for one task. **12) Too much data** - including everything, no filtering. **13) No pagination** - returning thousands of items. Follow REST principles and HTTP standards.

## REST API Documentation & Testing

**#. Why is API documentation important?**

Good documentation is crucial: **Adoption** - developers won't use what they don't understand. **Reduces support** - self-service reduces questions. **Developer experience** - easy integration means more users. **Internal alignment** - team understands API. **Onboarding** - new developers get up to speed. **Versioning** - clear deprecation notices. **Compliance** - required for some industries. **Marketing** - well-documented APIs attract developers. Poor docs lead to: misuse, support burden, frustrated developers, low adoption. Documentation should include: overview, authentication, endpoints (URL, methods, parameters, request/response examples), error codes, rate limits, SDKs, tutorials, changelog. Keep docs up to date - outdated docs worse than no docs. Use tools like OpenAPI/Swagger for interactive docs.

**#. What is OpenAPI Specification (Swagger)?**

OpenAPI (formerly Swagger) is a standard for describing REST APIs in machine-readable format (YAML or JSON). **Structure**: info (title, version, description), servers (base URLs), paths (endpoints), components (schemas, parameters, responses), security. **Example**: paths: /users: get: summary: "Get users" parameters: - name: status in: query schema: type: string responses: '200': description: "Success". **Benefits**: generate interactive docs (Swagger UI), generate code (clients, servers), validate requests/responses, design-first development, single source of truth. **Tools**: Swagger Editor (write specs), Swagger UI (visualize), Swagger Codegen (generate code), OpenAPI Generator. Most frameworks have libraries to generate OpenAPI from code annotations or vice versa. Industry standard for API documentation.

**#. How do you generate API documentation?**

Approaches: **1) Manual** - write markdown/HTML docs. Flexible but labor-intensive, gets outdated. **2) Annotation-based** - annotate code, generate docs. Examples: Spring @ApiOperation, FastAPI automatic docs. Keeps docs close to code. **3) OpenAPI first** - write OpenAPI spec, generate code from it. Design-first approach. **4) Postman collections** - export as documentation. Good for manual testing, less formal. **5) API management platforms** - Apigee, Kong, AWS API Gateway auto-generate docs. **Tools**: Swagger/OpenAPI, Spring REST Docs (tests generate docs), Redoc, Slate, Postman, API Blueprint. **Best practices**: automate generation (part of build), include examples, version docs with API, test examples (ensure they work), add tutorials/guides. Code annotations popular - docs stay in sync with code.

**#. What should comprehensive API documentation include?**

Essential sections: **1) Overview** - what API does, use cases, architecture. **2) Authentication** - how to authenticate, get credentials, examples. **3) Quick start** - minimal example to get started. **4) Endpoints** - for each endpoint: URL, HTTP method, description, parameters (path/query/body), request examples, response examples (success and error), status codes. **5) Data models** - schemas for request/response objects. **6) Error handling** - error codes, messages, how to handle. **7) Rate limiting** - limits, headers, best practices. **8) Versioning** - current version, migration guides. **9) SDKs** - client libraries if available. **10) Changelog** - what's new, deprecated, removed. **11) FAQs** - common questions. **12) Support** - how to get help. Use clear language, provide working examples, keep updated, make searchable.

**#. How do you test REST APIs?**

Testing approaches: **1) Unit tests** - test individual endpoints with mocked dependencies. Fast, isolated. **2) Integration tests** - test with real database, external services. More realistic. **3) Contract tests** - ensure API matches specification. **4) End-to-end tests** - full user flows across multiple endpoints. **5) Load tests** - performance under load. **6) Security tests** - penetration testing, vulnerability scanning. **Tools**: Postman, REST Assured (Java), Supertest (Node), pytest with requests (Python), JUnit/TestNG with RestTemplate (Spring). **What to test**: status codes, response body (structure, data correctness), headers, authentication/authorization, input validation, edge cases, error handling, pagination, filtering/sorting, performance, concurrent requests. **CI/CD**: automate tests, run on every commit. Maintain test data, use test database.

**#. What is Postman and how do you use it?**

Postman is a popular API development tool. **Features**: **Request building** - easy UI for creating requests with headers, parameters, body. **Collections** - organize requests, share with team. **Environments** - variables for different environments (dev, staging, prod). **Testing** - write JavaScript tests to validate responses. **Mock servers** - simulate API before building. **Documentation** - auto-generate from collections. **Monitoring** - scheduled test runs. **Collaboration** - shared workspaces. **Use cases**: manual testing during development, automated testing (Newman CLI), documentation, client demonstrations. **Workflow**: create request, set URL/method/headers, send, inspect response, write tests (Tests tab), organize in collection, export/share. Tests example: pm.test("Status is 200", () => { pm.response.to.have.status(200); }). Postman is essential for API development and testing.

**#. How do you write automated tests for REST APIs?**

Example with REST Assured (Java): `java @Test public void testGetUser() { given() .header("Authorization", "Bearer " + token) .when() .get("/api/users/123") .then() .statusCode(200) .body("id", equalTo(123)) .body("email", containsString("@")); }` **Structure**: Arrange (setup data), Act (make request), Assert (verify response). **Test coverage**: happy path, edge cases, error cases, authentication, authorization, validation, pagination. **Best practices**: independent tests (no dependencies), cleanup after tests, test data management, use fixtures/factories, meaningful test names, test one thing per test, avoid flaky tests. **CI/CD**: run tests automatically on commits. **Frameworks**: JUnit/TestNG + REST Assured (Java), pytest + requests (Python), Jest + Supertest (Node), Mocha + Chai (Node). Automated tests catch regressions, document expected behavior, enable confident refactoring.

**#. What is contract testing and why is it important?**

Contract testing verifies that API provider and consumer agree on interface contract. Important for: **microservices** - ensure service A expects what service B provides. **third-party integration** - both sides respect contract. **parallel development** - teams develop independently against contract. **regression prevention** - changes don't break contract. **Two approaches**: **1) Consumer-driven** (Pact) - consumer defines contract (expected requests/responses), provider validates against it. **2) Provider-driven** - provider defines contract (OpenAPI spec), consumer validates can handle it. **Benefits**: catch integration issues early, enable independent deployment, document integration points, faster than full integration tests. **Tools**: Pact, Spring Cloud Contract, Postman Contract Testing. Test runs on both sides - consumer checks provider matches expectations, provider checks doesn't break consumer expectations.

**#. How do you perform load and performance testing?**

Load testing ensures API handles expected traffic. **Metrics**: response time (p50, p95, p99), throughput (requests/second), error rate, resource usage (CPU, memory). **Tools**: JMeter, Gatling, k6, Locust, Artillery. **Scenarios**: steady load (consistent traffic), spike (sudden traffic increase), stress (gradually increase until failure), soak (prolonged load). **Example with k6**: `javascript import http from 'k6/http'; export default function() { http.get('https://api.example.com/users'); } export let options = { vus: 100, // virtual users duration: '5m', };` **Best practices**: test production-like environment, realistic test data, ramp up gradually, monitor backend resources, baseline performance, test regularly. Identify bottlenecks: slow database queries, missing indexes, inefficient code, resource limits. Performance testing critical for production readiness.

**#. What are some REST API testing best practices?**

Best practices: **1) Test pyramid** - many unit tests, fewer integration tests, few E2E tests. **2) Independent tests** - don't depend on order or other tests. **3) Idempotent tests** - can run multiple times safely. **4) Clean up** - delete test data after tests. **5) Test data** - separate test database, fixtures/factories for data. **6) Assertions** - test status code, headers, body structure, specific values. **7) Error cases** - test all error scenarios (validation, auth, not found). **8) Edge cases** - empty lists, null values, special characters. **9) Performance** - include some performance tests. **10) Security** - test authentication, authorization, input validation. **11) Automation** - run in CI/CD. **12) Documentation** - tests document expected behavior. **13) Mocking** - mock external dependencies. **14) Environments** - test against staging/dev, not prod. **15) Versioning** - test all supported versions.

**#. How do you mock external APIs in tests?**

Mocking isolates your tests from external dependencies. **Approaches**: **1) Mock libraries** - WireMock (Java), nock (Node), responses (Python). Define expected requests and responses. **2) Test doubles** - mock service classes in unit tests. **3) Containers** - Docker containers with test services. **4) Dedicated test environments** - external service provides test environment. **Example with WireMock**: `java @Rule public WireMockRule wireMock = new WireMockRule(8089); @Test public void test() { stubFor(get("/api/users/1") .willReturn(ok() .withHeader("Content-Type", "application/json") .withBody("{\"id\": 1, \"name\": \"John\"}"))); // test code that calls mocked API }` **Benefits**: fast tests, no network dependency, control responses (success, error, timeout), test error handling. **When not to mock**: integration tests (test real integration), contract tests. Mocking is essential for unit and integration test reliability.

**#. What is smoke testing for APIs?**

Smoke testing is basic sanity check to verify critical functionality works after deployment. **Purpose**: quick verification before extensive testing, catch major issues early, validate deployment success, monitor production health. **Scope**: test critical endpoints only, happy path scenarios, basic authentication, database connectivity. **Example**: 1) Login (auth works), 2) GET /users (database works), 3) POST /orders (write operations work), 4) Check rate limiting. **Frequency**: after every deployment, periodically in production (monitoring). **Fast**: should complete in minutes. **Tools**: simple scripts, Postman/Newman, monitoring tools (Datadog, New Relic). **CI/CD**: automated smoke tests post-deployment, rollback if fail. Think of it as "is the building on fire?" Not exhaustive, just checks basics work. Catches catastrophic failures quickly.

**#. How do you test API authentication and authorization?**

Testing auth is crucial. **Authentication tests**: 1) Valid credentials succeed. 2) Invalid credentials fail (401). 3) Missing credentials fail (401). 4) Expired tokens fail (401). 5) Malformed tokens fail (401). 6) Refresh token flow works. **Authorization tests**: 1) User can access allowed resources. 2) User can't access forbidden resources (403). 3) User can't access others' private resources. 4) Role-based access - admin can delete, regular user can't. 5) Resource ownership - user can update own profile, not others'. **Security tests**: 1) Tokens expire properly. 2) Logout invalidates tokens. 3) Password strength enforced. 4) Rate limiting on auth endpoints. 5) Brute force protection. **Example**: `java @Test public void userCannotDeleteOthersPost() { given().auth().oauth2(userToken) .when().delete("/posts/123") .then().statusCode(403); }` Test all permission combinations, edge cases around ownership, multi-tenant isolation.

**#. What are monitoring and observability for REST APIs?**

Monitoring tracks system health, observability understands why things happen. **Key metrics**: **1) Response time** - p50, p95, p99 latency. **2) Throughput** - requests per second. **3) Error rate** - percentage of 4xx/5xx responses. **4) Availability** - uptime percentage. **5) Resource usage** - CPU, memory, disk. **6) External dependencies** - third-party API latency. **Logs**: structured logging (JSON), include request ID for tracing, log errors with context, centralize logs (ELK, Splunk). **Metrics**: Prometheus, Grafana, DataDog, New Relic. **Tracing**: distributed tracing for microservices (Jaeger, Zipkin), trace requests across services. **Alerting**: alert on anomalies (high error rate, slow response, downtime). **Dashboards**: visualize metrics, real-time monitoring. **Health checks**: /health endpoint for load balancer. Good observability critical for production systems.

**#. How do you implement health check endpoints?**

Health check endpoints verify service health. **Basic**: GET /health returns 200 if healthy, 503 if not. Simple response: {status: "UP"}. **Detailed**: include component checks: {status: "UP", checks: {database: "UP", cache: "UP", externalAPI: "DOWN"}}. **Status codes**: 200 for healthy, 503 for unhealthy (load balancer stops routing). **What to check**: database connectivity, cache, critical dependencies, disk space, memory. **Shallow vs deep**: shallow (fast, just API is running), deep (checks dependencies). Use shallow for frequent load balancer checks, deep for monitoring. **Liveness vs readiness** (Kubernetes): liveness (should restart if fails), readiness (should receive traffic). **Security**: consider securing health endpoint or limiting info. **Example**: `java @GetMapping("/health") public ResponseEntity<Map> health() { boolean dbHealthy = checkDatabase(); boolean cacheHealthy = checkCache(); if (dbHealthy && cacheHealthy) return ok(Map.of("status", "UP")); return status(503).body(Map.of("status", "DOWN")); }` Essential for production monitoring.

## Advanced REST API Topics

**#. What is API gateway and what problems does it solve?**

API Gateway is a server that acts as single entry point for client requests, routing to appropriate microservices. **Problems solved**: **1) Routing** - routes requests to correct service. **2) Authentication** - centralized auth, services don't handle it. **3) Rate limiting** - enforce limits across services. **4) Caching** - cache responses, reduce backend load. **5) Load balancing** - distribute requests across instances. **6) Logging** - centralized logging and monitoring. **7) Protocol translation** - REST to gRPC, WebSocket. **8) Request/response transformation** - modify data. **9) CORS handling**. **10) API composition** - aggregate multiple service calls. **Benefits**: simplifies clients (one endpoint), decouples clients from services, cross-cutting concerns in one place. **Examples**: Kong, AWS API Gateway, Azure API Management, Netflix Zuul, Spring Cloud Gateway. Essential for microservices architecture. Gateway becomes single point of failure - must be highly available.

**#. What is API composition pattern?**

API composition aggregates data from multiple services into single response. **Problem**: in microservices, data is distributed across services. Client needs data from multiple services. Making multiple requests is inefficient. **Solution**: API Gateway or Backend for Frontend (BFF) makes multiple requests, combines responses, returns to client. **Example**: GET /orders/123/details. Gateway calls: order-service for order, user-service for user, product-service for products, payment-service for payment. Combines into one response. **Approaches**: **1) API Gateway** does composition. **2) BFF** - separate backend per client type (web, mobile) doing composition. **3) GraphQL** - client specifies what data needed. **Challenges**: performance (sequential calls), error handling (partial failures), consistency, transaction management. Use async calls, caching, circuit breakers. Alternative: event sourcing/CQRS with denormalized read models.

**#. What is the difference between REST and GraphQL?**

REST and GraphQL are different API paradigms. **REST**: multiple endpoints (resources), server defines response structure, over-fetching (get more than needed) or under-fetching (need multiple requests), versioning needed for breaking changes, standard HTTP caching. **GraphQL**: single endpoint, client specifies exactly what data needed in query, no over/under-fetching, strongly typed schema, no versioning needed (add fields, deprecate old), custom caching (more complex). **Example REST**: GET /users/123, GET /users/123/posts - two requests. **Example GraphQL**: one query: { user(id: 123) { name, posts { title } } }. **Use REST for**: CRUD APIs, standard HTTP caching, simple requirements, public APIs. **Use GraphQL for**: complex data fetching, multiple clients with different needs, reducing requests. Both have pros/cons - choose based on use case. REST is more common and simpler.

**#. How do you implement versioning in REST APIs?**

API versioning handles breaking changes while maintaining backward compatibility. **Strategies**: **1) URI versioning** - /v1/users, /v2/users. Most popular, visible, easy to route. **2) Query parameter** - /users?version=1. Flexible, less visible. **3) Header versioning** - Accept-Version: v1 or custom header. Keeps URI clean, less visible. **4) Media type versioning** - Accept: application/vnd.company.v1+json. Most RESTful, complex. **5) No versioning** - evolve compatibly (add fields, never remove). **Breaking changes**: removing fields, changing types, changing behavior. **Best practices**: version only on breaking changes, maintain multiple versions (2-3), deprecation policy (6-12 months), clear migration guides, semantic versioning (v1.2.3). URI versioning (/v1/) is most common for simplicity and visibility. Test all supported versions.

**#. What is API deprecation and how do you handle it?**

Deprecation is phasing out old API versions or endpoints. **Process**: **1) Announce** - communication to users, update docs with deprecation notice. **2) Sunset header** - Sunset: Sat, 31 Dec 2025 23:59:59 GMT indicates removal date. **3) Warning header** - Warning: 299 - "Deprecated API" in responses. **4) Grace period** - typically 6-12 months before removal. **5) Monitor usage** - track who still uses deprecated API. **6) Support** - help users migrate. **7) Remove** - after grace period, return 410 Gone. **Best practices**: clear timeline, migration guides, maintain old version during transition, email notifications to users, release notes, version new features (don't add to deprecated version). **Alternatives**: return 301 Moved Permanently to new endpoint, maintain indefinitely if possible. Never remove without notice - breaks trust and clients. Deprecation is part of API lifecycle management.

**#. How do you handle backward compatibility?**

Maintain compatibility so clients don't break. **Safe changes** (backward compatible): **Add** new optional fields, new endpoints, new optional query params, new response fields (clients ignore unknown fields). **Default values** for new required fields. **Deprecate** gracefully (don't remove). **Unsafe changes** (breaking): **Remove** fields, endpoints, rename fields, change types, change behavior, make optional fields required. **Strategies**: **1) Additive changes** - only add, never remove. **2) Versioning** - breaking changes require new version. **3) Content negotiation** - different representations. **4) Feature flags** - gradually roll out changes. **5) Deprecation** - announce before removing. **Example**: adding "middleName" field is safe (optional). Removing "name" field breaks clients. Changing "age" from integer to string breaks clients. Design for evolution - make fields optional, use extensible formats, avoid tight coupling. Test with old clients. Backward compatibility is crucial for API stability and user trust.

**#. What are webhooks and how do they differ from REST APIs?**

Webhooks are reverse APIs - server calls client when event occurs. **Traditional API**: client polls server: GET /orders?status=new (check for new orders). **Webhook**: server pushes to client when order created: POST https://client.com/webhook. **How it works**: 1) Client registers webhook URL with server. 2) Server stores URL. 3) When event occurs, server POSTs payload to URL. 4) Client processes and returns 200. **Benefits**: real-time notifications, no polling (efficient), immediate updates. **Challenges**: client must expose endpoint, reliability (retries if client down), security (verify sender with HMAC signature), ordering (events may arrive out of order). **Use cases**: payment notifications (Stripe), repository events (GitHub), order updates. **Implementation**: event occurs  async job posts to webhook URLs  retry on failure  log deliveries. Webhooks complement REST APIs for event-driven communication.

**#. What is the difference between synchronous and asynchronous REST APIs?**

**Synchronous**: client makes request, waits for response. Immediate result. Example: GET /users/123 returns user immediately. Simple, but client blocks. Suitable for fast operations. **Asynchronous**: client makes request, gets acknowledgment immediately, actual processing happens later. Example: POST /reports returns 202 Accepted with job ID, client polls GET /jobs/123 for status. **When to use async**: long-running operations (report generation, bulk import, video processing), prevents timeout, improves responsiveness. **Implementation**: 1) Accept request, create job, return 202 with Location header. 2) Process in background (job queue). 3) Client polls job endpoint or gets webhook when done. **Status endpoint**: GET /jobs/123 returns {status: "processing", progress: 45%} or {status: "completed", result: "..."}. **Challenges**: complexity, polling overhead (use webhooks), error handling. Use sync for fast operations (<5 sec), async for slow operations.

**#. How do you implement search functionality in REST APIs?**

Search approaches: **1) Query parameter** - GET /products?q=laptop&category=electronics. Simple full-text search. **2) Advanced filters** - /products?brand=Dell&price_min=500&price_max=1500&sort=price. Structured search. **3) Search endpoint** - POST /products/search with body: {query: "laptop", filters: {...}}. Complex queries. **4) GraphQL** - for complex filtering. **Features**: full-text search, filtering (multiple criteria), sorting, pagination, faceting (counts per category), highlighting (matched terms), suggestions/autocomplete, fuzzy matching. **Implementation**: **Database** - LIKE queries (slow), full-text indexes (better). **Search engines** - Elasticsearch, Solr (best for full-text). **Example**: GET /products?q=laptop&category=electronics&price_gte=500&sort=-price&page=1. Returns: {results: [...], facets: {brands: [{name: "Dell", count: 45}]}, total: 234}. Good search is complex - consider dedicated search service.

**#. What is rate limiting and how do you implement it?**

Rate limiting restricts requests per time period. **Algorithms**: **1) Fixed window** - 100 requests per hour, resets at :00. Simple, burst at boundaries. **2) Sliding window** - rolling hour window. More accurate, complex. **3) Token bucket** - bucket has N tokens, each request consumes token, tokens replenish at rate. Allows bursts. **4) Leaky bucket** - requests queued, processed at fixed rate. Smooths traffic. **Implementation**: store counters in Redis: key=user:123, value=count, TTL=1hr. Increment on request, check if exceeds limit. **Response**: 429 Too Many Requests, headers: X-RateLimit-Limit: 100, X-RateLimit-Remaining: 45, X-RateLimit-Reset: 1609459200, Retry-After: 3600. **Tiers**: free (100/hr), paid (10000/hr). **Granularity**: global, per user, per IP, per API key, per endpoint. **Strategies**: throttle (delay), reject (429), queue. Essential for API protection and fair usage.

**#. How do you implement API throttling?**

Throttling controls request rate to prevent overload. Different from rate limiting (reject after limit), throttling slows down (delays). **Approaches**: **1) Delay responses** - add artificial delay when approaching limit. **2) Queue requests** - process at controlled rate. **3) Reduce service** - lower quality (less data, cached) at high load. **4) Reject** - same as rate limiting, returns 429. **Implementation**: track request rate per client, if exceeds threshold, add delay or queue. **Example**: normal rate 100 req/sec, if client hits 120 req/sec, delay each request by 100ms. **Benefits**: protects backend, allows bursts within limits, better than hard reject. **Challenges**: complexity, client experience (slow responses). **Use cases**: API gateways, load balancers. **Tools**: NGINX, API gateways (Kong, AWS). Combine with rate limiting: soft limit (throttle), hard limit (reject). Configure differently per endpoint (POST /orders more strict than GET /products).

**#. What is API Gateway pattern vs Backend for Frontend (BFF)?**

Both aggregate/route requests but differ in scope. **API Gateway**: single gateway for all clients (web, mobile, IoT), general-purpose, routes to microservices, cross-cutting concerns (auth, rate limiting, logging), one team maintains. **Example**: Kong, AWS API Gateway. **BFF**: separate backend per client type, client-specific (web-bff, mobile-bff, iot-bff), tailored responses for client needs, each team owns their BFF, composition and transformation for specific client. **Example**: mobile-bff returns less data (bandwidth), web-bff returns more. **When to use**: Gateway for simple routing and shared concerns. BFF when clients have very different needs, want client teams to control backend, need specific optimizations per client. Can combine: Gateway (auth, routing)  BFF (composition)  Microservices. BFF is specialized gateway. Choice depends on client diversity and team structure.

**#. How do you handle distributed transactions in REST APIs?**

Distributed transactions across microservices are challenging. ACID transactions don't work across services. **Approaches**: **1) Avoid** - design to not need distributed transactions (aggregate services differently). **2) Saga pattern** - sequence of local transactions with compensating transactions for rollback. Choreography (events) or Orchestration (coordinator). **3) Two-Phase Commit (2PC)** - coordinator ensures all services commit or rollback. Blocking, not recommended for microservices. **4) Event sourcing** - append-only event log, rebuild state from events. **5) Eventually consistent** - accept temporary inconsistency. **Example Saga**: Order service creates order  Payment service charges  Inventory service reserves. If inventory fails, payment refund (compensating transaction). **Implementation**: message queue for reliability, idempotency (handle duplicate messages), compensation logic. **Challenges**: complexity, partial failures, debugging. Most microservices embrace eventual consistency over distributed transactions.

**#. What are API design best practices for microservices?**

Microservices-specific considerations: **1) Domain-driven design** - services organized around business domains. **2) Loose coupling** - services independent, communicate via APIs. **3) Service autonomy** - each service own database. **4) API contracts** - clear interfaces, versioning, contract tests. **5) Synchronous vs async** - REST for queries, events for updates. **6) Idempotency** - handle duplicate requests (network retries). **7) Timeouts** - set timeouts on all calls, fail fast. **8) Circuit breakers** - prevent cascade failures. **9) Service discovery** - services find each other (Consul, Eureka). **10) API Gateway** - single entry point, handles cross-cutting. **11) Backward compatibility** - services upgrade independently. **12) Monitoring** - distributed tracing across services. **13) Security** - service-to-service auth. **14) Data consistency** - eventual consistency, sagas. **15) Documentation** - OpenAPI specs per service. Microservices add complexity - good API design crucial.

**#. What are emerging trends in REST API development?**

Current trends: **1) GraphQL adoption** - alternative to REST for flexible data fetching. **2) gRPC** - for high-performance service-to-service communication. **3) AsyncAPI** - specification for async APIs (event-driven). **4) Serverless APIs** - API Gateway + Lambda functions, scale automatically. **5) AI/ML APIs** - exposing ML models as APIs. **6) Real-time APIs** - WebSockets, Server-Sent Events for live updates. **7) API-first development** - design API before implementation. **8) Better API security** - OAuth 2.1, API security frameworks. **9) API marketplaces** - monetizing APIs (RapidAPI, AWS Marketplace). **10) Low-code API platforms** - visual API builders. **11) API governance** - centralized control (policies, standards). **12) Developer experience focus** - better docs, SDKs, sandbox environments. **13) Edge computing APIs** - APIs at edge (CDN). **14) Federated APIs** - GraphQL Federation for microservices. REST remains dominant but evolving with new patterns and complementary technologies.
