# GIT

## Git Basics

**#. What is Git and how does it differ from other version control systems?**

Git is a distributed version control system (DVCS) for tracking changes in source code during software development. Created by Linus Torvalds in 2005 for Linux kernel development. **Key characteristics**: **1) Distributed** - every developer has full repository history locally. **2) Fast** - most operations are local (no network). **3) Branching** - lightweight, fast branch creation/merging. **4) Data integrity** - cryptographic hashing (SHA-1). **5) Non-linear development** - parallel branches. **vs Centralized VCS (SVN, Perforce)**: **Git**: distributed, offline work, local commits, full history local, fast branching. **Centralized**: single server, needs network, central repository, limited offline. **vs Other DVCS (Mercurial)**: similar concepts but Git more popular, GitHub ecosystem. **Benefits**: **1) Speed** - local operations. **2) Flexibility** - branching strategies. **3) Collaboration** - distributed workflows. **4) Backup** - every clone is full backup. **5) Open source** - free, widely adopted. Git is industry standard for version control.

**#. Explain the difference between Git and GitHub.**

Git and GitHub are different but related. **Git**: **1) Software** - version control system. **2) Local** - runs on your machine. **3) Command-line/GUI** - git commands. **4) Core functionality** - track changes, branches, commits. **5) Created** - 2005 by Linus Torvalds. **GitHub**: **1) Platform** - web-based hosting service for Git repositories. **2) Remote** - cloud-based. **3) Web interface** - browse repos, pull requests, issues. **4) Collaboration features** - PR reviews, issues, wikis, actions. **5) Created** - 2008 by Tom Preston-Werner. **Relationship**: Git is tool, GitHub is platform using Git. **Alternatives to GitHub**: GitLab, Bitbucket, Azure DevOps. **Use Git without GitHub**: yes, local only or other hosting. **Use GitHub without Git**: no, GitHub built on Git. **Analogy**: Git = email software (Outlook), GitHub = email service (Gmail). Many developers confuse them, but Git = VCS, GitHub = hosting + collaboration platform.

**#. What are the three states in Git?**

Git has three main states for files: **1) Modified** - file changed but not committed. Working directory. **2) Staged** - file marked to go into next commit. Staging area (index). **3) Committed** - data safely stored in local repository. Git directory (.git). **Workflow**: **1) Modify** - edit files in working directory. **2) Stage** - git add (move to staging area). **3) Commit** - git commit (save to repository). **Areas**: **Working Directory** - actual files you edit. **Staging Area (Index)** - preparation area for next commit. **Repository (.git directory)** - Git metadata and object database. **Commands**: git status (see state), git add (modified → staged), git commit (staged → committed). **Why staging?**: allows selective commits - modify 5 files, stage 3, commit 3, continue working on other 2. **Best practice**: stage related changes together, atomic commits. Understanding three states fundamental to Git workflow.

**#. Explain basic Git commands: init, clone, add, commit, push, pull.**

**git init** - initialize new Git repository in current directory. Creates .git folder. Use: start tracking existing project. **git clone <url>** - copy remote repository to local. Downloads full history. Use: get existing project. **git add <file>** - stage changes for commit. git add . (all files), git add *.js (pattern). Moves modified → staged. **git commit -m "message"** - save staged changes to repository. Creates commit with message. -m for inline message, without -m opens editor. **git push <remote> <branch>** - upload local commits to remote. git push origin main. Updates remote repository. **git pull <remote> <branch>** - download remote changes and merge. git pull origin main. Combines fetch + merge. **Typical workflow**: git clone → edit files → git add . → git commit -m "fix bug" → git push origin main. **Best practices**: descriptive commit messages, commit often (atomic changes), pull before push (avoid conflicts). These six commands cover 80% of daily Git usage.

**#. What is a Git commit and what does it contain?**

A commit is a snapshot of your repository at a point in time. **Contents**: **1) Snapshot** - complete state of all tracked files (not just changes). **2) Metadata** - author, email, timestamp, message. **3) Parent commit(s)** - reference to previous commit (forms history graph). **4) SHA-1 hash** - unique 40-character identifier (e.g., a3b5c7...). **5) Tree** - directory structure. **Not a diff**: Git stores snapshots, not deltas (though can compute diffs). **Immutable**: once created, commit never changes (SHA ensures integrity). **Commands**: git commit -m "message" (create commit), git log (view commits), git show <hash> (inspect commit). **Good commit**: **1) Atomic** - one logical change. **2) Complete** - doesn't break build. **3) Descriptive message** - what and why. **Example**: "Fix null pointer in user login (issue #123)". **Commit graph**: commits form DAG (directed acyclic graph) showing project history. Understanding commits essential - they're Git's fundamental unit.

**#. Explain Git branching and why it's important.**

Branches are parallel lines of development. **Concept**: pointer to a commit. Master/main is just a branch. **Creating branch**: git branch feature-login (create), git checkout feature-login or git switch feature-login (switch). **Combined**: git checkout -b feature-login. **Why important**: **1) Isolation** - work on features independently. **2) Experimentation** - try changes without affecting main code. **3) Parallel development** - multiple features simultaneously. **4) Collaboration** - team members work on different branches. **5) Release management** - production vs development branches. **Lightweight**: branches in Git are just pointers (41 bytes), very cheap to create. **Example workflow**: main branch (production) → create feature branch → develop → merge back to main. **Commands**: git branch (list), git branch -d (delete), git branch -m (rename). **Best practices**: branch per feature, descriptive names (feature/user-auth, bugfix/login-error), delete after merge, keep main stable. Git's branching is killer feature - enables workflows like Git Flow, GitHub Flow.

**#. What is the difference between git fetch and git pull?**

Both download data from remote, but differ in merging. **git fetch**: **1) Downloads** - gets commits, branches, tags from remote. **2) Updates remote-tracking branches** - origin/main updated. **3) No merge** - doesn't change working directory. **4) Safe** - review before merging. **git pull**: **1) Downloads** - same as fetch. **2) Merges** - automatically merges into current branch. **3) Shortcut** - git pull = git fetch + git merge. **4) Can conflict** - might create merge conflicts. **Detailed**: **fetch**: origin/main updated, local main unchanged. Inspect: git log origin/main, then git merge origin/main manually. **pull**: origin/main fetched and merged into local main automatically. **When to use**: **fetch** - review changes first, inspect before merging, safer. **pull** - quick updates, trust remote, common workflow. **Best practice**: git fetch regularly (stay updated), review changes, git merge when ready. Pull convenient but fetch + merge gives more control. Many developers prefer fetch for safety.

**#. What is a merge conflict and how do you resolve it?**

Merge conflict occurs when Git can't automatically merge changes (same lines modified differently). **Causes**: **1) Same line edited** - two branches modify same line differently. **2) One deletes file, other edits** - conflicting operations. **3) Complex changes** - overlapping modifications. **Conflict markers**: Git adds markers to file: <<<<<<< HEAD (your changes), ======= (separator), >>>>>>> branch-name (their changes). **Resolution steps**: **1) Identify** - git status shows conflicted files. **2) Open file** - edit to resolve, remove markers. **3) Choose** - keep yours, keep theirs, or combine. **4) Stage** - git add <file> (marks resolved). **5) Commit** - git commit (completes merge). **Tools**: **1) Manual** - edit in text editor. **2) Merge tools** - git mergetool (kdiff3, meld, vimdiff). **3) IDE** - VS Code, IntelliJ have conflict resolution UI. **Prevention**: **1) Frequent merges** - keep branches up-to-date. **2) Small commits** - easier to merge. **3) Communication** - coordinate changes. **4) Pull before push**. Conflicts are normal in collaborative development, knowing resolution essential.

**#. Explain Git merge vs Git rebase.**

Two ways to integrate changes from one branch to another. **git merge**: **1) Creates merge commit** - special commit with two parents. **2) Preserves history** - shows when branches merged. **3) Non-destructive** - existing branches unchanged. **4) Creates diamond** - history graph shows divergence and convergence. **git rebase**: **1) Rewrites history** - moves commits to new base. **2) Linear history** - appears as if worked sequentially. **3) No merge commit** - cleaner history. **4) Destructive** - changes commit hashes. **Example - merge**: feature branched from main → both have new commits → merge creates new commit combining both. History shows branch. **Example - rebase**: feature branched from main → main has new commits → rebase moves feature commits onto latest main → linear history. **When to use**: **Merge** - public branches, preserve history, safer. **Rebase** - private branches, clean history, before merging to main. **Golden rule**: never rebase commits pushed to public repo (others may have them). Merge preserves truth, rebase creates clean narrative.

**#. What is Git stash and when do you use it?**

Git stash temporarily saves uncommitted changes without committing. **Use cases**: **1) Switch branches** - need to switch but work incomplete, not ready to commit. **2) Pull changes** - working directory must be clean to pull. **3) Context switch** - urgent bug fix, save current work. **4) Experiment** - try something, want to revert easily. **Commands**: **git stash** or **git stash push** - save changes, clean working directory. **git stash list** - list stashes (stash@{0}, stash@{1}...). **git stash apply** - reapply last stash, keep stash. **git stash pop** - reapply and delete stash. **git stash drop** - delete stash. **git stash show** - view stash contents. **git stash branch <name>** - create branch from stash. **Example**: working on feature → need to fix bug → git stash → checkout main → fix bug → commit → checkout feature → git stash pop. **Stash includes**: staged and unstaged changes. **Limitations**: doesn't stash untracked files (use git stash -u). Stash is temporary storage for work-in-progress.

**#. Explain Git tags and their types.**

Tags are named references to specific commits, typically for releases. **Types**: **Lightweight** - simple pointer to commit (like branch that doesn't move). **Annotated** - full object with tagger name, email, date, message, optional GPG signature. **Creating**: **Lightweight**: git tag v1.0.0. **Annotated**: git tag -a v1.0.0 -m "Release version 1.0.0". **Listing**: git tag (all tags), git tag -l "v1.*" (pattern). **Viewing**: git show v1.0.0 (tag info and commit). **Checking out**: git checkout v1.0.0 (detached HEAD state). **Pushing**: tags not pushed by default. git push origin v1.0.0 (specific tag), git push origin --tags (all tags). **Deleting**: git tag -d v1.0.0 (local), git push origin --delete v1.0.0 (remote). **Use cases**: **1) Releases** - v1.0.0, v2.1.3 (semantic versioning). **2) Milestones** - beta-1, rc-1. **Best practices**: use annotated tags for releases (more info), semantic versioning, tag after testing, push tags explicitly. Tags are immutable markers in history, essential for release management.

**#. What is the .gitignore file and how does it work?**

.gitignore specifies intentionally untracked files Git should ignore. **Purpose**: **1) Exclude generated files** - build artifacts, compiled code. **2) Secrets** - passwords, API keys. **3) IDE files** - .idea, .vscode. **4) Dependencies** - node_modules, vendor. **5) OS files** - .DS_Store, Thumbs.db. **Syntax**: **1) Pattern matching** - * (wildcard), ? (single char), **/ (directory marker). **2) Negation** - ! (include exception). **3) Comments** - # for comments. **Example**: *.log (all .log files), /node_modules (root node_modules only), build/ (entire build directory), !important.log (exception). **Location**: usually project root, can have multiple in subdirectories. **Limitations**: only affects untracked files. Already tracked files must be removed: git rm --cached <file>. **Templates**: GitHub provides templates for languages (Python, Node, Java). **Best practices**: add .gitignore at project start, exclude generated/secret/environment-specific files, commit .gitignore. Proper .gitignore keeps repository clean and secure.

**#. Explain Git remote and related commands.**

Remote: version of your repository hosted elsewhere (GitHub, GitLab). **Commands**: **git remote** - list remotes. **git remote -v** - list with URLs. **git remote add <name> <url>** - add remote (git remote add origin https://github.com/user/repo.git). **git remote remove <name>** - remove remote. **git remote rename <old> <new>** - rename. **git remote show <name>** - detailed info (git remote show origin). **Origin**: conventional name for primary remote. Not special, just default. **Multiple remotes**: can have multiple (origin, upstream, deploy). Common in forked repos: origin (your fork), upstream (original repo). **Fetch from remote**: git fetch origin. **Push to remote**: git push origin main. **Pull from remote**: git pull origin main. **Set upstream**: git push -u origin main (-u sets tracking). **Tracking branches**: git branch -vv (shows tracking). **Use cases**: **1) Collaboration** - share code. **2) Backup** - remote is backup. **3) Deployment** - push to production remote. Understanding remotes essential for distributed Git workflow.

**#. What is HEAD in Git?**

HEAD is a pointer to the current branch reference (which points to current commit). **Normally**: HEAD → branch → commit. Example: HEAD → main → commit abc123. **Detached HEAD**: HEAD points directly to commit, not branch. Happens when checking out commit or tag: git checkout abc123. **States**: **Attached** - HEAD points to branch. Commits advance branch. Normal state. **Detached** - HEAD points to commit. Commits not attached to branch, can be lost. Warning state. **Commands**: **View**: cat .git/HEAD (shows ref: refs/heads/main). **References**: HEAD (current), HEAD^ or HEAD~1 (parent), HEAD^^ or HEAD~2 (grandparent). **Use in commands**: git diff HEAD~1 (compare with previous commit), git reset HEAD~1 (undo commit). **Detached HEAD workflow**: checkout old commit → make changes → git checkout -b new-branch (attach to new branch). **Symbolic ref**: HEAD is symbolic reference to branch. **Understanding**: HEAD = "where you are now". Most commands operate relative to HEAD. Critical concept for navigating Git history.

**#. Explain the difference between git reset, git revert, and git checkout.**

Three commands for undoing changes, but different approaches. **git reset**: **1) Moves branch** - moves current branch pointer backward. **2) Modes** - --soft (keep changes staged), --mixed (default, keep changes unstaged), --hard (discard changes). **3) Rewrites history** - dangerous for pushed commits. **4) Example**: git reset --hard HEAD~1 (undo last commit, discard changes). **git revert**: **1) Creates commit** - new commit that undoes specified commit. **2) Preserves history** - safe for public branches. **3) Example**: git revert abc123 (creates commit undoing abc123). **git checkout**: **1) Switches branches/commits** - changes HEAD. **2) Discards changes** - git checkout -- file (discard working directory changes). **3) Replaced by switch/restore** - git switch (branches), git restore (files). **When to use**: **Reset** - undo local commits (not pushed). **Revert** - undo pushed commits (safe). **Checkout** - switch branches or discard local changes. **Golden rule**: never reset public history (others may have it). Use revert for public branches. Understanding difference prevents data loss.

## Git Advanced

**#. What is Git cherry-pick and when do you use it?**

Cherry-pick applies changes from specific commit(s) to current branch. **Command**: git cherry-pick <commit-hash>. **Use cases**: **1) Selective merge** - want one commit from branch, not entire branch. **2) Bug fix** - fix committed to development, need in production quickly. **3) Hotfix** - apply production fix to development. **4) Mistake** - committed to wrong branch, cherry-pick to correct branch. **Example**: feature branch has 10 commits, only commit abc123 needed in main → git checkout main → git cherry-pick abc123. **Multiple commits**: git cherry-pick abc123 def456. **Range**: git cherry-pick abc123..def456. **Conflicts**: like merge, can have conflicts, resolve and git cherry-pick --continue. **History**: creates new commit with different hash (not same as original). **Best practices**: **1) Use sparingly** - prefer merge/rebase. **2) Document** - note cherry-picked commits. **3) Avoid duplicates** - can create duplicate changes. Cherry-pick is surgical tool for specific commits.

**#. Explain Git submodules.**

Submodules allow including other Git repositories within your repository. **Use case**: **1) Dependencies** - include library repositories. **2) Reusable components** - shared code across projects. **3) Large projects** - separate repos for components. **Adding**: git submodule add <repository-url> <path>. Creates .gitmodules file (configuration). **Cloning with submodules**: git clone --recursive <repo> or git clone → git submodule init → git submodule update. **Updating submodule**: cd submodule → git pull → cd back → git add submodule → git commit (parent repo stores submodule commit hash). **Commands**: git submodule status (view submodules), git submodule update (update to recorded commit). **Challenges**: **1) Complexity** - adds layer of complexity. **2) Workflow** - need to update submodule separately. **3) Version management** - parent repo points to specific commit, not branch. **Alternatives**: package managers (npm, maven), subtree, monorepo. **Best practices**: document submodule usage, update regularly, avoid deep nesting. Submodules powerful but add complexity.

**#. What is Git rebase interactive and its uses?**

Interactive rebase allows editing commit history. **Command**: git rebase -i <base-commit>. Opens editor with commit list. **Actions**: **pick** - use commit as-is. **reword** - change commit message. **edit** - pause to amend commit. **squash** - combine with previous commit. **fixup** - like squash but discard message. **drop** - remove commit. **reorder** - move commits. **Use cases**: **1) Squash commits** - combine multiple WIP commits into one clean commit. **2) Fix commit messages** - reword typos, improve clarity. **3) Remove commits** - drop unwanted commits. **4) Split commits** - edit, reset, make multiple commits. **5) Reorder** - organize commits logically. **Example - squash**: git rebase -i HEAD~3 (last 3 commits) → change pick to squash for 2 commits → save. 3 commits become 1. **Danger**: rewrites history, only use on local/unpushed commits. **Best practices**: clean up before pushing, squash fixup commits, maintain logical commit structure. Interactive rebase is powerful history editing tool.

**#. What are Git hooks and common examples?**

Git hooks are scripts triggered by Git events. **Location**: .git/hooks/ directory. **Types**: **Client-side** - run locally (pre-commit, pre-push, post-merge). **Server-side** - run on server (pre-receive, post-receive, update). **Common hooks**: **pre-commit** - runs before commit (linting, tests). Abort commit on failure (exit non-zero). **commit-msg** - validate commit message format. **pre-push** - runs before push (tests, build). Prevent broken code from pushing. **post-merge** - runs after merge (install dependencies, migrations). **post-checkout** - runs after checkout. **Setup**: hooks are scripts (shell, Python, etc.), make executable (chmod +x), non-zero exit aborts operation. **Example - pre-commit**: run linter, if fails abort commit. **Sharing**: .git/hooks not tracked. Solutions: commit sample hooks to scripts/ directory, use tools (husky for Node.js, pre-commit for Python). **Use cases**: **1) Code quality** - lint, format. **2) Testing** - run tests before commit/push. **3) Automation** - update dependencies, generate docs. Hooks automate workflows and enforce standards.

**#. Explain Git bisect for debugging.**

Git bisect uses binary search to find commit that introduced bug. **Concept**: mark good (working) and bad (broken) commits, Git checks commits in between, you test, mark good/bad, repeat until bug-introducing commit found. **Commands**: **git bisect start** - begin bisect session. **git bisect bad** - mark current commit as bad. **git bisect good <commit>** - mark known good commit. Git checks out middle commit. Test, then: **git bisect good** or **git bisect bad**. Repeat. **git bisect reset** - end session, return to original HEAD. **Automated**: git bisect run <test-script> (automatically runs test, determines good/bad). **Example**: bug in production, working 2 weeks ago → git bisect start → git bisect bad → git bisect good <2-weeks-ago-commit> → Git checks out middle → test → mark good/bad → repeat ~4-7 times → found. **Benefits**: **1) Efficient** - log(n) tests vs linear. **2) Systematic** - no guessing. **3) Automated** - with test script. **Best practices**: known good starting point, reproducible bug, automated test if possible. Bisect powerful for finding regression.

**#. What is Git reflog and when is it useful?**

Reflog (reference log) tracks updates to branch tips and HEAD. **Purpose**: **1) Safety net** - recover lost commits. **2) History** - see where HEAD has been. **3) Recovery** - undo mistakes (reset, checkout, rebase). **Command**: **git reflog** or **git reflog show HEAD** - list HEAD movements. Format: commit hash, HEAD@{n}, action, message. **Use cases**: **1) Recover lost commits** - did git reset --hard, want to undo. Reflog shows old HEAD, git reset --hard <commit>. **2) Undo rebase** - rebased, want to undo. Reflog shows pre-rebase state. **3) Find deleted branch** - deleted branch, reflog shows last commit. **4) See history** - what you've been doing. **Expiration**: reflog entries expire (default 90 days, 30 days for unreachable). **Example**: git reset --hard HEAD~3 (mistake) → git reflog → find previous HEAD → git reset --hard <hash> (recovered). **Other reflogs**: git reflog show main (main branch reflog). **Alias**: HEAD@{1} = one move ago, HEAD@{2} = two moves ago. Reflog is Git's safety net, invaluable for recovery.

**#. Explain Git worktree and its use cases.**

Git worktree allows multiple working directories for same repository. **Problem**: working on feature, urgent bug fix needed. Options: stash, commit incomplete work, or clone repo again. **Solution**: worktree - create additional working directory, different branches simultaneously. **Commands**: **git worktree add <path> <branch>** - create worktree. git worktree add ../project-hotfix hotfix-branch. **git worktree list** - list worktrees. **git worktree remove <path>** - remove worktree. **Use cases**: **1) Context switching** - work on feature and fix bug simultaneously. **2) Testing** - test one branch while working on another. **3) Code review** - review PR in separate worktree. **4) Parallel development** - multiple features. **Example**: main directory - feature branch, ../project-hotfix - main branch for bug fix. Switch terminals, work on both. **Shared repository**: worktrees share .git directory (refs, objects), but separate working directories and index. **Cleanup**: git worktree prune (remove deleted worktrees). **Best practices**: temporary use (don't keep many), descriptive paths, cleanup when done. Worktree eliminates need for multiple clones.

**#. What is Git LFS (Large File Storage)?**

Git LFS handles large files efficiently. **Problem**: Git stores full history, large files (videos, datasets, binaries) bloat repository, slow cloning/fetching. **Solution**: Git LFS stores large files on separate server, Git repo has pointer files. **How it works**: **1) Track file types** - git lfs track "*.psd" (Photoshop files). Creates .gitattributes. **2) Add/commit** - git add, git commit as normal. **3) Storage** - actual file stored on LFS server, pointer in Git. **4) Clone** - git clone downloads pointers, git lfs pull downloads actual files. **Commands**: **git lfs install** - install LFS (once per user). **git lfs track "*.mp4"** - track file types. **git lfs ls-files** - list LFS files. **git lfs pull** - download LFS files. **Pointer file**: small text file with hash and size, replaces actual file in Git. **Hosting**: GitHub, GitLab, Bitbucket support LFS. Storage limits apply. **Use cases**: **1) Media** - images, videos. **2) Datasets** - ML datasets. **3) Game assets** - 3D models, textures. **4) Binaries** - compiled executables. LFS keeps repo small while handling large files.

**#. How do you handle sensitive data accidentally committed?**

Accidentally committed secrets (passwords, API keys) to Git requires careful handling. **Immediate**: **1) Don't just delete** - history still contains secret, accessible. **2) Rotate secret** - change password/key immediately (assume compromised). **Removal**: **git filter-branch** (legacy) or **BFG Repo-Cleaner** (recommended) or **git filter-repo** (modern). **BFG Repo-Cleaner**: **1) Clone** - git clone --mirror repo.git. **2) Run BFG** - bfg --delete-files secrets.txt or bfg --replace-text passwords.txt. **3) Cleanup** - cd repo.git → git reflog expire --expire=now --all → git gc --prune=now --aggressive. **4) Force push** - git push --force. **Alternative - filter-repo**: git filter-repo --path secrets.txt --invert-paths. **Considerations**: **1) Force push** - rewrites history, affects collaborators. **2) Forks** - can't control forks, secrets still there. **3) Caches** - GitHub caches, secrets may be cached. **Prevention**: **1) .gitignore** - ignore config files. **2) Environment variables** - don't hardcode secrets. **3) Hooks** - pre-commit hooks scan for secrets. **4) Secret scanning** - GitHub, GitGuardian automatically detect. **Best practice**: prevention (never commit secrets), if happens, rotate immediately + clean history.

**#. What are Git flow and GitHub flow?**

Branching strategies for teams. **Git Flow**: **Branches**: **1) main** - production code. **2) develop** - integration branch. **3) feature/** - features off develop. **4) release/** - release preparation. **5) hotfix/** - urgent fixes off main. **Flow**: develop feature → merge to develop → create release branch → test → merge to main and develop → tag release → hotfix if needed. **Pros**: structure, clear releases. **Cons**: complex, many branches. **Use**: scheduled releases, multiple versions. **GitHub Flow**: **Branches**: **1) main** - always deployable. **2) feature branches** - short-lived. **Flow**: create branch → commit → pull request → review → merge to main → deploy. **Pros**: simple, continuous deployment. **Cons**: less structure. **Use**: continuous deployment, web apps. **Other flows**: **GitLab Flow** (environment branches), **Trunk-Based Development** (short-lived branches off trunk). **Choosing**: depends on release cadence (scheduled vs continuous), team size, deployment process. Most modern teams use GitHub Flow or similar simplified flow.

**#. How do you write good commit messages?**

Good commit messages are documentation and communication. **Format**: **Subject line** (50 chars) - imperative mood ("Fix bug", not "Fixed bug"), capitalized, no period. **Blank line**. **Body** (optional, 72 chars per line) - explain what and why, not how. **Example**: "Add user authentication\n\nImplement JWT-based auth to secure API endpoints. Required for enterprise customers. Fixes #123". **Rules**: **1) Imperative mood** - "Add feature", "Fix bug". **2) Capitalize** - "Add", not "add". **3) No period** - subject line. **4) 50/72 rule** - 50 char subject, 72 char body lines. **5) Why, not how** - code shows how, message explains why. **6) Reference issues** - "Fixes #123", "Relates to #456". **7) One logical change** - atomic commits. **Bad**: "fix", "wip", "asdfasdf", "fixed a bunch of stuff". **Good**: "Fix null pointer exception in login validation". **Tools**: commitlint (enforce convention), commitizen (interactive). **Templates**: .gitmessage file (git config commit.template). **Best practices**: clear, descriptive, explain context, reference issues. Good messages make history useful.

**#. Explain Git sparse checkout.**

Sparse checkout allows checking out subset of repository. **Use case**: monorepo with multiple projects, only need one. **Process**: **1) Clone** - git clone --filter=blob:none --sparse <repo> (clone without files). **2) Sparse checkout** - git sparse-checkout init --cone. **3) Add directories** - git sparse-checkout set project1 project2. **4) Checkout** - git checkout main (now only project1, project2 checked out). **Commands**: **git sparse-checkout list** - show included paths. **git sparse-checkout add <path>** - add path. **git sparse-checkout disable** - disable sparse checkout. **Cone mode**: optimized for directory-based patterns (--cone). **Benefits**: **1) Faster** - less files to checkout. **2) Smaller working directory** - only needed files. **3) Focus** - work on specific part. **Use cases**: **1) Monorepos** - large repos with multiple projects. **2) Partial access** - mobile team only needs app directory. **Example**: Android repo has app/, server/, web/ → developer working on app only checks out app/. Sparse checkout improves performance for large repos.

**#. How do you handle merge vs squash vs rebase when merging pull requests?**

Different strategies for integrating PRs. **Merge commit**: **1) Creates merge commit** - preserves all commits from PR. **2) History** - shows branch existed. **3) Graph** - non-linear. **Pros**: complete history, easy to revert PR. **Cons**: cluttered history with many commits. **Squash and merge**: **1) Combines commits** - all PR commits into single commit. **2) History** - linear, one commit per PR. **Pros**: clean history, each commit is feature/fix. **Cons**: loses individual commits, harder to revert parts. **Rebase and merge**: **1) Reapplies commits** - PR commits added linearly to base. **2) No merge commit** - linear history. **Pros**: clean linear history, preserves individual commits. **Cons**: changes commit hashes, can be confusing. **Choosing**: **Merge** - preserve full history, complex PRs. **Squash** - clean history, simple PRs (most common). **Rebase** - linear history, preserve commits. **Best practices**: **1) Team convention** - be consistent. **2) Documentation** - squash message includes overview. **3) Atomic PRs** - smaller PRs easier to squash. Most teams use squash for clean history with one commit per feature.

**#. What are Git attributes and their uses?**

.gitattributes file defines attributes for paths. **Use cases**: **1) Line endings** - normalize across platforms. **2) Diff/merge drivers** - custom diff/merge for file types. **3) Export ignore** - exclude files from git archive. **4) Language statistics** - GitHub language detection. **5) LFS** - large file tracking. **Line endings**: `* text=auto` (auto normalize), `*.sh text eol=lf` (Unix), `*.bat text eol=crlf` (Windows). **Binary files**: `*.jpg binary` (no diff, no line ending conversion). **Diff**: `*.pdf diff=pdf` (custom diff driver). **Merge**: `database.lock merge=ours` (always use our version). **Export-ignore**: `tests/ export-ignore` (excluded from git archive). **LFS**: `*.psd filter=lfs diff=lfs merge=lfs -text`. **Example .gitattributes**: * text=auto, *.png binary, *.md text, docs/ export-ignore. **Location**: repository root (applies to all), subdirectory (applies to subtree). **Benefits**: **1) Consistency** - across team. **2) Automation** - Git handles conversions. **3) Tool integration** - custom diff/merge tools. Attributes configure Git behavior per file type.

**#. What are Git best practices summary?**

Comprehensive Git best practices: **Commits**: **1) Atomic** - one logical change per commit. **2) Descriptive messages** - clear what and why. **3) Frequent** - commit often (easy to revert). **4) Test before commit** - don't break build. **Branches**: **1) Feature branches** - one branch per feature. **2) Descriptive names** - feature/user-auth, bugfix/login. **3) Delete after merge** - keep clean. **4) Keep updated** - merge main regularly (avoid drift). **Workflow**: **1) Pull before push** - stay synced. **2) Review before push** - check git diff. **3) Use pull requests** - code review, discussion. **4) Resolve conflicts carefully** - understand both sides. **Repository**: **1) .gitignore** - exclude generated/secret files. **2) README** - document project. **3) Small commits** - easier to review, revert. **4) No secrets** - use environment variables. **History**: **1) Don't rewrite public history** - never force push to shared branches. **2) Clean local history** - interactive rebase before PR. **3) Use tags** - mark releases. **Collaboration**: **1) Consistent strategy** - team agrees on workflow (Git Flow, GitHub Flow). **2) Communication** - discuss big changes. **3) Documentation** - commit messages, PR descriptions. Following practices ensures smooth collaboration and maintainable history.
