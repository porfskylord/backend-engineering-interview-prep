# AWS (Amazon Web Services)

## AWS Fundamentals

**#. What is AWS and what are its core services?**

AWS (Amazon Web Services) is Amazon's cloud computing platform, providing on-demand computing resources and services. Launched 2006, market leader in cloud. **Core services**: **Compute** - EC2 (virtual servers), Lambda (serverless), ECS/EKS (containers). **Storage** - S3 (object storage), EBS (block storage), EFS (file storage). **Database** - RDS (relational), DynamoDB (NoSQL), Aurora. **Networking** - VPC (virtual network), CloudFront (CDN), Route 53 (DNS). **Security** - IAM (identity), KMS (encryption). **Monitoring** - CloudWatch (monitoring, logs). **Benefits**: **1) Scalability** - scale up/down on demand. **2) Cost-effective** - pay as you go. **3) Global** - data centers worldwide. **4) Reliable** - high availability, redundancy. **5) Secure** - compliance, encryption. **Deployment models**: **Public cloud** (AWS), **Hybrid** (AWS + on-premises), **Multi-cloud** (AWS + Azure/GCP). **Use cases**: web applications, mobile backends, big data, ML, IoT, disaster recovery. AWS dominates cloud market (~32%), followed by Azure, GCP.

**#. Explain AWS regions and availability zones.**

AWS infrastructure distributed globally. **Region**: geographic area (e.g., us-east-1, eu-west-1). Independent, isolated. **23 regions worldwide** (as of 2024). **Availability Zone (AZ)**: one or more discrete data centers within region. Each region has **2-6 AZs**. Physically separated (different buildings, power, networking) but connected with low-latency links. **Purpose**: **1) High availability** - distribute across AZs, survive AZ failure. **2) Low latency** - choose region near users. **3) Compliance** - data residency (EU data in EU region). **Naming**: us-east-1a, us-east-1b (AZs in us-east-1 region). **Best practice**: deploy across multiple AZs (Auto Scaling, load balancers). **Example**: RDS Multi-AZ - primary in AZ-a, standby in AZ-b, automatic failover. **Edge Locations**: additional sites for CloudFront (CDN), lower latency for content delivery. **Choosing region**: **1) Latency** - near users. **2) Cost** - prices vary. **3) Services** - not all services in all regions. **4) Compliance** - data laws. Understanding regions/AZs fundamental to designing HA systems.

**#. What is Amazon EC2 and its instance types?**

EC2 (Elastic Compute Cloud) provides resizable virtual servers (instances) in cloud. **Key concepts**: **Instance** - virtual server. **AMI (Amazon Machine Image)** - OS template. **Instance types** - CPU, memory, storage, networking combinations. **Categories**: **1) General Purpose** (t3, m5) - balanced, web servers. **2) Compute Optimized** (c5) - high CPU, batch processing. **3) Memory Optimized** (r5) - large memory, databases. **4) Storage Optimized** (i3) - high I/O, data warehouses. **5) Accelerated Computing** (p3, g4) - GPU, ML, graphics. **Naming**: t3.micro (family.size). **Pricing**: **1) On-Demand** - pay per hour/second, flexible. **2) Reserved** - 1-3 year commitment, 30-70% discount. **3) Spot** - bid on spare capacity, up to 90% discount, can be terminated. **4) Savings Plans** - flexible commitment. **Features**: **Auto Scaling** - scale based on demand. **Elastic IP** - static IP. **Security Groups** - firewall rules. **Use cases**: web apps, databases, batch processing, ML. **Best practices**: right-size instances, use Auto Scaling, combine pricing models, terminate unused instances.

**#. Explain Amazon S3 and its storage classes.**

S3 (Simple Storage Service) is object storage for files (objects) in buckets. **Concepts**: **Bucket** - container (globally unique name). **Object** - file + metadata (key-value). **Key** - unique identifier (filename with path). **Durability**: 99.999999999% (11 nines) - highly durable. **Availability**: 99.99% - highly available. **Storage classes**: **1) S3 Standard** - frequently accessed, low latency, high throughput. **2) S3 Intelligent-Tiering** - auto-moves between tiers based on access. **3) S3 Standard-IA (Infrequent Access)** - lower cost, accessed less frequently, retrieval fee. **4) S3 One Zone-IA** - lower cost, single AZ (less durability). **5) S3 Glacier** - archival, minutes to hours retrieval. **6) S3 Glacier Deep Archive** - lowest cost, 12-hour retrieval. **Features**: **Versioning** - keep multiple versions. **Lifecycle policies** - auto-transition to cheaper classes or delete. **Encryption** - server-side (SSE-S3, SSE-KMS) or client-side. **Access control** - IAM policies, bucket policies, ACLs. **Use cases**: static websites, backups, data lakes, archives. **Best practices**: appropriate storage class, lifecycle policies, versioning for critical data, encryption.

**#. What is AWS Lambda and serverless computing?**

Lambda is serverless compute - run code without managing servers. **Concept**: **1) Upload code** - function in Python, Node.js, Java, Go, etc. **2) Trigger** - event triggers function (API call, S3 upload, DynamoDB change). **3) Execution** - AWS runs function, scales automatically. **4) Pay per use** - charged per request and execution time (milliseconds). **Benefits**: **1) No servers** - no provisioning, patching, scaling. **2) Auto-scaling** - scales with load. **3) Cost-effective** - pay only when running. **4) Fast deployment** - deploy code quickly. **Triggers**: **API Gateway** (HTTP requests), **S3** (object uploads), **DynamoDB Streams** (table changes), **EventBridge** (scheduled), **SQS** (messages), **SNS** (notifications). **Limitations**: **1) Timeout** - max 15 minutes. **2) Memory** - max 10GB. **3) Cold start** - initial latency. **4) Stateless** - no persistent storage (use S3, DynamoDB). **Use cases**: API backends, data processing, automation, real-time file processing. **Architecture**: event-driven, microservices, serverless full-stack (API Gateway + Lambda + DynamoDB). Lambda enables pay-per-use, auto-scaling compute.

**#. Explain Amazon RDS and its database engines.**

RDS (Relational Database Service) is managed relational database. **AWS manages**: provisioning, patching, backups, monitoring. **You manage**: schema, queries, optimization. **Engines**: **1) MySQL** - open-source. **2) PostgreSQL** - open-source, advanced features. **3) MariaDB** - MySQL fork. **4) Oracle** - commercial, license included or BYOL. **5) SQL Server** - Microsoft. **6) Amazon Aurora** - AWS-built, MySQL/PostgreSQL compatible, 5x performance. **Features**: **1) Multi-AZ** - synchronous replica in another AZ, automatic failover. **2) Read Replicas** - async replicas for read scaling (up to 15). **3) Automated Backups** - daily snapshots + transaction logs, 1-35 day retention. **4) Manual Snapshots** - user-initiated, kept until deleted. **5) Encryption** - at rest (KMS) and in transit (SSL). **6) Monitoring** - CloudWatch metrics. **vs EC2 database**: RDS managed (backups, patching), EC2 more control but more work. **Use cases**: OLTP applications, web apps, standard relational workloads. **Best practices**: Multi-AZ for production, read replicas for scaling, appropriate instance size, automated backups.

**#. What is Amazon DynamoDB?**

DynamoDB is fully managed NoSQL database. **Key-value and document** store. **Features**: **1) Fully managed** - no servers, auto-scaling. **2) Performance** - single-digit millisecond latency at any scale. **3) Scalable** - automatic scaling. **4) Highly available** - multi-AZ replication. **5) Flexible** - schema-less. **Concepts**: **Table** - collection of items. **Item** - record (like row). **Attribute** - field (like column). **Primary Key** - partition key (required) + optional sort key. **Indexes**: **GSI (Global Secondary Index)** - different partition/sort key. **LSI (Local Secondary Index)** - same partition key, different sort key. **Capacity modes**: **1) On-Demand** - pay per request, auto-scaling. **2) Provisioned** - specify read/write capacity units (RCU/WCU), cost-effective for predictable load. **Features**: **Streams** - capture changes (like CDC). **Global Tables** - multi-region replication. **Transactions** - ACID across multiple items. **TTL** - auto-delete expired items. **Use cases**: mobile/web apps, gaming leaderboards, IoT, serverless applications. **vs RDS**: DynamoDB for scale and performance, RDS for complex queries and transactions. DynamoDB is fast, scalable NoSQL.

**#. Explain AWS VPC (Virtual Private Cloud).**

VPC is isolated virtual network in AWS. **Components**: **1) Subnets** - IP range segment, public or private. **2) Internet Gateway** - allows internet access. **3) NAT Gateway** - allows private subnet instances to access internet (outbound). **4) Route Tables** - define traffic routing. **5) Security Groups** - instance-level firewall (stateful). **6) NACLs (Network ACLs)** - subnet-level firewall (stateless). **Public subnet**: has route to Internet Gateway, instances have public IPs. **Private subnet**: no direct internet access, use NAT Gateway for outbound. **Architecture example**: **Public subnet** - load balancer, bastion host. **Private subnet** - application servers, databases. **Security**: **Security Groups** - allow inbound/outbound rules per instance. **NACLs** - allow/deny rules per subnet. **Best practice**: least privilege. **VPC Peering**: connect VPCs (same/different accounts, regions). **VPN**: connect on-premises to VPC. **Direct Connect**: dedicated network connection. **Use cases**: multi-tier applications, hybrid cloud, isolated environments. **Default VPC**: AWS creates default VPC per region, but custom VPC recommended for production. VPC provides network isolation and control.

**#. What is AWS IAM (Identity and Access Management)?**

IAM manages access to AWS services and resources. **Components**: **1) Users** - individuals with credentials (password, access keys). **2) Groups** - collection of users with shared permissions. **3) Roles** - assumed by users, applications, services for temporary permissions. **4) Policies** - JSON documents defining permissions. **Policies**: **Identity-based** - attached to users, groups, roles. **Resource-based** - attached to resources (S3 buckets). **Example policy**: {Effect: "Allow", Action: "s3:GetObject", Resource: "arn:aws:s3:::mybucket/*"}. **Permissions**: **Allow** or **Deny**. Explicit deny overrides allow. **MFA**: multi-factor authentication for sensitive operations. **Best practices**: **1) Root account** - don't use for daily tasks, enable MFA. **2) Least privilege** - grant minimum permissions needed. **3) Use roles** - for applications, not hardcoded keys. **4) Rotate credentials** - regular rotation. **5) Enable MFA** - for privileged users. **6) IAM Access Analyzer** - identify overly permissive access. **7) Use AWS Organizations** - centralized management across accounts. **Service roles**: EC2 instances assume roles to access other services (S3, DynamoDB) securely. IAM is foundation of AWS security.

**#. Explain AWS Auto Scaling and Elastic Load Balancing.**

**Auto Scaling**: automatically adjusts number of EC2 instances based on demand. **Components**: **1) Launch Template** - instance configuration (AMI, instance type, security groups). **2) Auto Scaling Group (ASG)** - manages instances (min, max, desired capacity). **3) Scaling Policies** - rules for scaling (target tracking, step, scheduled). **Scaling types**: **Target Tracking** - maintain metric (CPU at 50%). **Step Scaling** - scale based on CloudWatch alarms (if CPU > 80%, add 2 instances). **Scheduled** - scale at specific times. **Predictive** - ML-based forecasting. **Benefits**: **1) Availability** - replace unhealthy instances. **2) Cost** - scale down during low demand. **3) Elasticity** - handle traffic spikes. **Elastic Load Balancing (ELB)**: distributes traffic across instances. **Types**: **1) ALB (Application)** - HTTP/HTTPS, layer 7, path-based routing. **2) NLB (Network)** - TCP/UDP, layer 4, extreme performance. **3) CLB (Classic)** - legacy. **Health Checks**: ELB checks instance health, ASG replaces unhealthy. **Architecture**: Internet → ELB → ASG → EC2 instances across AZs. **Use cases**: web apps, APIs, microservices. Auto Scaling + ELB provide HA and elasticity.

**#. What is Amazon CloudFront?**

CloudFront is AWS's Content Delivery Network (CDN). **Purpose**: deliver content with low latency by caching at edge locations worldwide. **How it works**: **1) Origin** - source content (S3, EC2, ELB, custom server). **2) Distribution** - CDN configuration. **3) Edge Locations** - cache content (200+ worldwide). **4) User request** - user requests content from nearest edge location. If cached, served from edge (fast). If not, fetched from origin, cached, then served. **Types**: **Web distribution** - static/dynamic web content (HTML, CSS, JS, images). **RTMP distribution** - media streaming (deprecated). **Features**: **1) Caching** - configurable TTL. **2) Geo-restriction** - allow/deny countries. **3) SSL/TLS** - custom certificates. **4) Lambda@Edge** - run code at edge. **5) Security** - AWS WAF integration, DDoS protection. **6) Compression** - gzip, brotli. **Use cases**: **1) Static websites** - host on S3, deliver via CloudFront. **2) Video streaming** - VOD, live. **3) API acceleration** - cache API responses. **4) Software distribution** - downloads. **Benefits**: **1) Performance** - lower latency. **2) Cost** - reduce origin load. **3) Scalability** - handle traffic spikes. CloudFront speeds up global content delivery.

**#. Explain Amazon Route 53.**

Route 53 is AWS's DNS (Domain Name System) service. **Functions**: **1) Domain Registration** - buy domains. **2) DNS routing** - resolve domain names to IP addresses. **3) Health checks** - monitor endpoints. **Routing policies**: **1) Simple** - single resource (one IP). **2) Weighted** - distribute traffic by percentage (A/B testing). **3) Latency** - route to region with lowest latency. **4) Failover** - primary-secondary (if primary fails, route to secondary). **5) Geolocation** - route based on user location. **6) Geoproximity** - route based on geographic proximity with bias. **7) Multi-value** - return multiple IPs, client chooses. **Health checks**: monitors endpoints (HTTP, HTTPS, TCP), integrates with CloudWatch. Failover policy uses health checks. **DNS records**: **A** (IPv4), **AAAA** (IPv6), **CNAME** (alias), **Alias** (AWS-specific, free). **Use cases**: **1) Global applications** - latency-based routing. **2) Disaster recovery** - failover routing. **3) Load distribution** - weighted routing. **4) Multi-region** - geolocation routing. **Benefits**: **1) Reliable** - 100% uptime SLA. **2) Fast** - global network. **3) Integrated** - with AWS services. Route 53 provides intelligent DNS routing.

**#. What is AWS CloudWatch?**

CloudWatch is monitoring and observability service. **Components**: **1) Metrics** - time-series data (CPU, memory, custom). **2) Logs** - collect, monitor, analyze logs. **3) Alarms** - notify or trigger actions based on metrics. **4) Dashboards** - visualize metrics. **5) Events (EventBridge)** - respond to state changes. **Metrics**: **AWS metrics** - EC2 CPU, S3 requests, RDS connections (automatic). **Custom metrics** - application metrics via API. **Resolution**: standard (5 min), detailed (1 min), high-resolution (1 sec). **Logs**: **Log Groups** - collection of log streams. **Log Streams** - sequence of log events. **Insights** - query logs (SQL-like). **Export** - to S3 or stream to Lambda, Kinesis. **Alarms**: threshold-based, trigger actions (SNS notification, Auto Scaling, EC2 action). **Example**: CPU > 80% for 5 min → send email via SNS. **Dashboards**: custom views combining metrics from multiple services. **Use cases**: **1) Monitoring** - infrastructure health. **2) Troubleshooting** - logs analysis. **3) Performance** - track metrics. **4) Automation** - event-driven actions. **Best practices**: set alarms for critical metrics, use log insights for troubleshooting, retain logs appropriately. CloudWatch is central to AWS observability.

**#. Explain AWS Elastic Beanstalk.**

Elastic Beanstalk is PaaS (Platform as a Service) for deploying web applications. **Concept**: upload code, Beanstalk handles infrastructure (EC2, load balancer, Auto Scaling, monitoring). **Supported platforms**: Java, .NET, PHP, Node.js, Python, Ruby, Go, Docker. **How it works**: **1) Create application** - name + platform. **2) Upload code** - zip file or Git. **3) Beanstalk deploys** - provisions resources, deploys code. **4) Access application** - via URL. **Components**: **Application** - logical container. **Environment** - running application version (web server or worker). **Version** - code iteration. **Configuration**: customize instance type, scaling, database, environment variables via console or .ebextensions config files. **Deployment options**: **All at once** - deploy to all instances (downtime). **Rolling** - batch updates (partial capacity). **Rolling with additional batch** - maintain full capacity. **Immutable** - new instances, swap after success. **Blue/Green** - separate environment, DNS swap. **Use cases**: **1) Web apps** - quick deployment. **2) Microservices** - Docker containers. **3) Workers** - background jobs. **vs Lambda**: Beanstalk for traditional apps, Lambda for serverless. **vs ECS**: Beanstalk simpler, ECS more control. Beanstalk simplifies deployment for developers.

**#. What is AWS CloudFormation?**

CloudFormation is Infrastructure as Code (IaC) service - define AWS resources in templates, provision as stacks. **Template**: JSON or YAML file defining resources. **Stack**: collection of resources managed as single unit. **How it works**: **1) Write template** - define EC2, S3, RDS, etc. **2) Create stack** - CloudFormation provisions resources. **3) Update stack** - modify template, CloudFormation updates resources. **4) Delete stack** - CloudFormation deletes all resources. **Template structure**: **Resources** (required) - AWS resources. **Parameters** - input values. **Mappings** - key-value maps. **Outputs** - values to export. **Conditions** - conditional resource creation. **Example**: define VPC, subnets, EC2, RDS in template → create stack → entire infrastructure provisioned. **Benefits**: **1) Repeatability** - deploy same stack multiple times. **2) Version control** - templates in Git. **3) Automation** - infrastructure changes via code. **4) Rollback** - automatic rollback on failure. **5) Drift detection** - detect manual changes. **Use cases**: **1) Multi-environment** - dev, staging, prod from same template. **2) Disaster recovery** - recreate infrastructure. **3) Compliance** - consistent infrastructure. **vs Terraform**: CloudFormation AWS-specific, Terraform multi-cloud. CloudFormation automates infrastructure deployment.

## AWS Advanced & Best Practices

**#. What is AWS Lambda cold start and how do you optimize it?**

Cold start: delay when Lambda function invoked after being idle. **Causes**: **1) New execution context** - Lambda provisions container, loads code, initializes runtime. **2) Initialization code** - imports, connections, startup logic. **Cold start time**: varies by runtime (Node.js ~200-500ms, Python ~300-700ms, Java ~1-3s), memory, code size, dependencies. **Warm start**: reuses existing execution context, much faster (<10ms). **Optimization**: **1) Provisioned Concurrency** - pre-warm containers, always ready (costs more). **2) Increase memory** - more CPU allocated, faster init. **3) Reduce package size** - smaller deployment, faster load. **4) Minimize dependencies** - fewer imports. **5) Lazy loading** - initialize outside handler, reuse across invocations. **6) Choose runtime** - compiled languages (Go) faster cold start than JVM (Java). **7) Keep functions warm** - periodic invocations (CloudWatch scheduled event). **8) Connection pooling** - reuse database connections. **Example**: Initialize DB connection outside handler (reused), not inside (reconnect every time). **Monitoring**: X-Ray traces show init duration. Cold starts impact latency-sensitive applications, optimize for real-time APIs.

**#. Explain AWS cost optimization strategies.**

AWS cost management essential for efficiency. **Strategies**: **1) Right-sizing** - choose appropriate instance types, don't over-provision. Use CloudWatch metrics, AWS Compute Optimizer. **2) Reserved Instances** - commit 1-3 years for 30-70% discount (EC2, RDS, ElastiCache). **3) Savings Plans** - flexible commitment for compute. **4) Spot Instances** - up to 90% discount, batch jobs, fault-tolerant workloads. **5) Auto Scaling** - scale down during low demand. **6) S3 Lifecycle Policies** - move infrequent data to cheaper storage classes (IA, Glacier). **7) Serverless** - Lambda, Fargate pay per use (vs always-on EC2). **8) Delete unused resources** - snapshots, EIPs, unattached EBS volumes. **9) Use CloudFront** - reduce data transfer costs. **10) Monitoring** - Cost Explorer, Budgets, Cost Anomaly Detection. **Tools**: **AWS Cost Explorer** - visualize spending. **AWS Budgets** - set alerts. **Trusted Advisor** - cost optimization recommendations. **AWS Cost and Usage Report** - detailed billing data. **Tagging**: resource tagging for cost allocation (project, team, environment). **Best practices**: regular cost reviews, shutdown dev environments off-hours, reserved instances for steady workloads. Cost optimization is ongoing process.

**#. What is AWS Well-Architected Framework?**

Well-Architected Framework provides best practices for designing cloud systems. **Six Pillars**: **1) Operational Excellence** - run and monitor systems, continuous improvement. Principles: automate, small frequent changes, document, anticipate failure. **2) Security** - protect data, systems, assets. Principles: strong identity, traceability, defense in depth, least privilege, encryption. **3) Reliability** - system recovers from failures, meets demand. Principles: test recovery, auto-scale, stop guessing capacity. **4) Performance Efficiency** - efficient use of resources. Principles: democratize advanced technologies, go global, serverless, experiment. **5) Cost Optimization** - avoid unnecessary costs. Principles: consumption model, measure efficiency, managed services. **6) Sustainability** - minimize environmental impact. Principles: understand impact, maximize utilization, use managed services. **Tools**: **Well-Architected Tool** - review workloads against framework. **Lenses** - domain-specific guidance (SaaS, Serverless, Machine Learning). **Best practices**: design reviews, architecture documentation, continuous improvement. Framework guides building secure, reliable, efficient, cost-effective systems.

**#. Explain AWS security best practices.**

Comprehensive security approach. **IAM**: **1) Root account** - MFA, don't use daily. **2) Least privilege** - minimum permissions. **3) Roles over credentials** - for applications. **4) MFA** - for privileged users. **5) Rotate keys** - access keys, passwords. **Network**: **1) VPC** - isolated network. **2) Security Groups** - least privilege rules. **3) Private subnets** - for sensitive resources. **4) VPN/Direct Connect** - secure connection to on-premises. **5) AWS WAF** - protect web apps. **Data**: **1) Encryption at rest** - S3 (SSE), EBS, RDS (KMS). **2) Encryption in transit** - HTTPS, SSL/TLS. **3) KMS** - key management. **4) Secrets Manager** - store secrets securely. **Monitoring**: **1) CloudTrail** - log API calls. **2) Config** - track resource changes. **3) GuardDuty** - threat detection. **4) Security Hub** - centralized security findings. **Compliance**: **1) Shared Responsibility Model** - AWS secures infrastructure, you secure workloads. **2) Compliance programs** - SOC, PCI-DSS, HIPAA. **Best practices**: defense in depth, automate security, prepare for incidents, regular audits. Security is shared responsibility between AWS and customer.

**#. What is AWS Systems Manager?**

Systems Manager provides operational data and automation for AWS resources. **Capabilities**: **1) Operations Management** - OpsCenter (operational insights), Explorer (dashboard). **2) Application Management** - Parameter Store (configuration), AppConfig. **3) Change Management** - Change Manager, Maintenance Windows. **4) Node Management** - Session Manager (access instances), Run Command (execute commands), Patch Manager (automate patching), State Manager (enforce configuration). **5) Shared Resources** - Documents (automation scripts). **Parameter Store**: store configuration and secrets (free alternative to Secrets Manager for non-rotated secrets). Hierarchy: /app/prod/db-url, /app/dev/db-url. **Session Manager**: access EC2/on-premises instances without SSH keys, bastion hosts (more secure). Logs sessions. **Run Command**: execute commands on multiple instances (yum update, install agents). **Patch Manager**: automate OS patching across fleet. **Use cases**: **1) Configuration management** - centralized parameters. **2) Compliance** - patch management. **3) Access management** - Session Manager. **4) Automation** - Run Command, Automation. Systems Manager provides operational visibility and control.

**#. Explain AWS database migration strategies.**

Migrating databases to AWS requires planning. **Tools**: **1) AWS Database Migration Service (DMS)** - migrate databases with minimal downtime. Supports homogeneous (Oracle → Aurora MySQL) and heterogeneous (Oracle → Aurora). **2) AWS Schema Conversion Tool (SCT)** - convert schema for heterogeneous migrations. **Strategies**: **1) Lift and Shift** - EC2-hosted database, minimal changes. **2) Replatform** - RDS, managed benefits. **3) Refactor** - DynamoDB, Aurora, redesign. **DMS**: **Replication instance** - runs migration tasks. **Endpoints** - source and target databases. **Task** - migration configuration. **Types**: **Full load** - one-time migration. **CDC (Change Data Capture)** - continuous replication. **Full + CDC** - migrate then ongoing replication. **Process**: **1) Assessment** - SCT generates migration assessment report. **2) Schema conversion** - SCT converts schema. **3) Data migration** - DMS migrates data. **4) Testing** - validate in target. **5) Cutover** - switch application. **Challenges**: **1) Downtime** - minimize with CDC. **2) Data consistency** - validate. **3) Application compatibility** - test. **Best practices**: pilot migration, test thoroughly, plan cutover, monitor closely. DMS simplifies database migrations.

**#. What is AWS Elastic Container Service (ECS) and Fargate?**

**ECS** manages Docker containers on AWS. **Components**: **1) Cluster** - logical group of resources. **2) Task Definition** - blueprint (Docker image, CPU, memory, ports). **3) Task** - running instance of task definition. **4) Service** - maintains desired task count, load balancing. **Launch types**: **1) EC2** - run containers on EC2 instances (you manage instances). **2) Fargate** - serverless, AWS manages infrastructure. **Fargate**: **Benefits**: **1) Serverless** - no instance management. **2) Pay per task** - only running time. **3) Auto-scaling** - automatic. **4) Simplified** - focus on application. **When to use**: **ECS on EC2** - need control, specialized instances, cost optimization (Reserved Instances). **Fargate** - simplicity, variable workloads, don't want to manage instances. **vs EKS**: ECS AWS-proprietary, simpler. EKS Kubernetes, portable, more complex. **vs Lambda**: containers for longer-running workloads, custom runtimes. Lambda for event-driven, short functions. **Use cases**: microservices, batch processing, web applications. ECS provides container orchestration, Fargate removes infrastructure management.

**#. Explain AWS disaster recovery strategies.**

AWS enables various DR strategies. **RPO (Recovery Point Objective)**: acceptable data loss (time). **RTO (Recovery Time Objective)**: acceptable downtime. **Strategies (cost/complexity increasing, RTO/RPO decreasing)**: **1) Backup and Restore** - backup data to S3, Glacier. Restore when needed. **RPO/RTO**: hours. **Cost**: low. **Use**: less critical, can tolerate hours downtime. **2) Pilot Light** - minimal resources (database) always running, scale up on disaster. **RPO/RTO**: 10s of minutes. **Cost**: moderate. **3) Warm Standby** - scaled-down production running, scale up on disaster. **RPO/RTO**: minutes. **Cost**: higher. **4) Multi-Site Active-Active** - full production in multiple regions, active-active. **RPO/RTO**: near-zero. **Cost**: highest. **Implementation**: **1) Backup** - automated backups to S3 (snapshots, DB backups). **2) Multi-AZ** - within region redundancy. **3) Multi-Region** - cross-region replication (S3, DynamoDB Global Tables, Aurora Global Database). **4) Route 53** - health checks, failover routing. **Best practices**: test DR plan regularly, automate recovery, document procedures, monitor recovery metrics. Choose strategy based on business requirements and budget.

**#. What are AWS managed services vs self-managed?**

**Managed services**: AWS operates infrastructure. **Self-managed**: you operate on AWS infrastructure. **Managed**: **Benefits**: **1) Less operational overhead** - no patching, backups. **2) Faster** - deploy quickly. **3) Scalable** - automatic scaling. **4) HA** - built-in redundancy. **Examples**: RDS (vs MySQL on EC2), DynamoDB (vs Cassandra on EC2), ElastiCache (vs Redis on EC2), Lambda (vs containers on EC2). **Drawbacks**: **1) Less control** - can't customize at OS level. **2) Vendor lock-in** - AWS-specific. **3) Cost** - sometimes more expensive than self-managed (though total cost often lower considering operations). **Self-managed**: **Benefits**: **1) Full control** - customize everything. **2) Flexibility** - any software. **3) Portability** - not AWS-specific. **Examples**: PostgreSQL on EC2 (vs RDS), Elasticsearch on EC2 (vs OpenSearch Service), Kafka on EC2 (vs MSK). **Drawbacks**: **1) Operational burden** - patching, backups, scaling. **2) Slower** - more setup time. **Choosing**: **Managed** for most use cases (focus on application, not infrastructure). **Self-managed** when need specific customization or have expertise/resources. Trend towards managed services for operational efficiency.

**#. Explain AWS serverless architecture patterns.**

Serverless: no server management, pay-per-use, auto-scaling. **Core services**: Lambda (compute), API Gateway (HTTP API), DynamoDB (database), S3 (storage), EventBridge (events), SQS/SNS (messaging). **Patterns**: **1) Web API**: API Gateway → Lambda → DynamoDB. Scalable REST API. **2) Real-time file processing**: S3 upload event → Lambda → process (resize image, transcode video). **3) Stream processing**: DynamoDB Streams → Lambda → process changes, update analytics. **4) Scheduled tasks**: EventBridge rule (cron) → Lambda → perform task (cleanup, reports). **5) Event-driven**: SNS topic → Lambda subscribers → process notifications. **6) Workflow orchestration**: Step Functions coordinate multiple Lambdas. **7) Backend for Frontend**: mobile/web → API Gateway → Lambda → services. **Benefits**: **1) No servers** - fully managed. **2) Cost** - pay per request. **3) Scale** - automatic. **4) Speed** - faster development. **Challenges**: **1) Cold starts** - latency. **2) Debugging** - distributed. **3) Vendor lock-in** - AWS-specific. **4) Limits** - execution time, memory. **Best practices**: idempotent functions, async where possible, monitoring (X-Ray), CI/CD. Serverless ideal for event-driven, variable workloads.

**#. What is AWS CodePipeline and CI/CD on AWS?**

AWS provides managed CI/CD services. **CodePipeline**: orchestrates CI/CD workflow. **Stages**: Source → Build → Test → Deploy. **CodeCommit**: Git repository (like GitHub). **CodeBuild**: managed build service (compile, test, package). **CodeDeploy**: automated deployment to EC2, Lambda, ECS, on-premises. **CodeArtifact**: artifact repository (npm, Maven, PyPI). **Pipeline example**: **1) Source** - push to CodeCommit/GitHub. **2) Build** - CodeBuild compiles code, runs tests, creates artifact. **3) Test** - integration tests. **4) Deploy** - CodeDeploy deploys to production (rolling, blue-green, canary). **Integration**: **Third-party** - GitHub, Jenkins, Bitbucket. **Notifications** - SNS, ChatBot. **Approval** - manual approval gates. **Benefits**: **1) Automated** - consistent deployments. **2) Fast** - rapid iterations. **3) Safe** - testing before production. **4) Auditable** - deployment history. **Best practices**: **1) Infrastructure as Code** - CloudFormation in pipeline. **2) Automated testing** - unit, integration, security. **3) Blue-green deployments** - zero downtime. **4) Monitoring** - CloudWatch alarms. AWS CI/CD services enable DevOps practices.

**#. Explain AWS multi-account strategy and AWS Organizations.**

**AWS Organizations**: centrally manage multiple AWS accounts. **Why multiple accounts**: **1) Isolation** - separate production, development, security. **2) Cost tracking** - per team, project, environment. **3) Compliance** - regulatory boundaries. **4) Security** - blast radius containment. **Structure**: **Organization** - root containing accounts. **Organizational Units (OUs)** - group accounts (Production OU, Development OU). **Accounts** - individual AWS accounts. **Features**: **1) Consolidated billing** - single bill for all accounts. **2) Service Control Policies (SCPs)** - restrict permissions across accounts (e.g., prevent deleting CloudTrail logs). **3) Resource sharing** - RAM (Resource Access Manager) share resources. **4) Account creation** - programmatically create accounts. **5) Tag policies** - enforce tagging. **Best practices**: **1) Separate accounts** - workloads, environments, teams. **2) Landing Zone** - AWS Control Tower automates setup. **3) Central logging** - aggregate CloudTrail, Config to central account. **4) Least privilege SCPs** - restrict risky operations. **Example**: Management account (billing, organization), Security account (CloudTrail, GuardDuty), Development accounts, Production accounts. Multi-account strategy improves security, compliance, cost management.

**#. What is AWS PrivateLink?**

PrivateLink provides private connectivity to AWS services and customer services. **Problem**: accessing AWS services (S3, DynamoDB) typically goes over internet. PrivateLink keeps traffic within AWS network. **How it works**: **1) VPC Endpoint** - interface in your VPC. **2) Service** - AWS service or your own service (NLB). **3) Traffic** - flows privately via PrivateLink, never leaves AWS network. **Types**: **1) Interface Endpoint** - ENI (elastic network interface) in subnet, for most services (EC2, S3). **2) Gateway Endpoint** - target in route table, for S3 and DynamoDB (free). **Benefits**: **1) Security** - no internet exposure. **2) Performance** - lower latency, higher throughput. **3) Compliance** - data doesn't traverse internet. **4) Simplified** - no IGW, NAT, VPN needed. **Use cases**: **1) Access S3 privately** - from private subnet without NAT. **2) Expose your service** - to other VPCs/accounts securely (SaaS providers). **3) Hybrid** - on-premises to AWS services via VPN/Direct Connect + PrivateLink. **Example**: EC2 in private subnet → S3 Gateway Endpoint → S3 (traffic stays in AWS network, no NAT Gateway cost). PrivateLink enhances security and performance.

**#. Explain AWS hybrid cloud strategies.**

Hybrid: combine on-premises and AWS. **Connectivity**: **1) Site-to-Site VPN** - encrypted connection over internet. Fast setup, variable bandwidth. **2) AWS Direct Connect** - dedicated 1-10Gbps connection. Consistent bandwidth, higher cost. **3) VPN over Direct Connect** - encrypted + dedicated. **Storage**: **1) AWS Storage Gateway** - bridge on-premises and S3. Types: File Gateway (NFS/SMB), Volume Gateway (iSCSI), Tape Gateway (backup). **2) DataSync** - fast data transfer to/from AWS (NFS, SMB, S3, EFS). **Compute**: **1) AWS Outposts** - AWS infrastructure on-premises (same APIs, services). **2) Wavelength** - ultra-low latency at 5G edge. **Database**: **1) DMS** - replicate on-premises DB to RDS. **2) Aurora Global Database** - replicate across regions. **Management**: **1) Systems Manager** - manage on-premises and cloud instances. **2) Organizations** - unified management. **Use cases**: **1) Cloud migration** - gradual move to cloud. **2) Burst to cloud** - on-premises primary, cloud for overflow. **3) Disaster recovery** - on-premises primary, cloud DR. **4) Data processing** - store on-premises, process in cloud. Hybrid provides flexibility during cloud adoption.

**#. What are AWS best practices summary?**

Comprehensive AWS best practices: **Architecture**: **1) Well-Architected Framework** - follow six pillars. **2) Multi-AZ** - deploy across AZs for HA. **3) Multi-Region** - for DR and global apps. **4) Loose coupling** - services communicate via queues, load balancers. **Security**: **1) IAM** - least privilege, MFA, roles. **2) Encryption** - at rest and in transit. **3) Network** - security groups, NACLs, private subnets. **4) Monitoring** - CloudTrail, GuardDuty. **5) Compliance** - understand Shared Responsibility Model. **Cost**: **1) Right-sizing** - appropriate instance types. **2) Reserved/Spot** - for cost savings. **3) Auto Scaling** - scale down when idle. **4) S3 Lifecycle** - cheaper storage classes. **5) Monitoring** - Cost Explorer, Budgets. **Operations**: **1) Automation** - Infrastructure as Code (CloudFormation, Terraform). **2) CI/CD** - CodePipeline. **3) Monitoring** - CloudWatch alarms, dashboards. **4) Logging** - centralized logging. **5) Backups** - automated backups, test restores. **Reliability**: **1) HA** - multi-AZ, load balancing. **2) DR** - tested DR plan. **3) Chaos engineering** - test failure scenarios. **Development**: **1) Managed services** - prefer over self-managed. **2) Serverless** - for event-driven workloads. **3) Containers** - ECS, Fargate for microservices. Following these practices ensures secure, reliable, cost-effective AWS deployments.
